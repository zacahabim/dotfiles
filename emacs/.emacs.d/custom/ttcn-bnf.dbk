<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE article PUBLIC
  "-//OASIS//DTD DocBook EBNF Module V1.2b1//EN" "dbebnf.dtd">
<article lang="en">
  <title>TTCN-3 Grammar</title>
  <articleinfo>
    <editor>
      <firstname>W. Martin</firstname>
      <surname>Borgert</surname>
      <email>debacle@debian.org</email>
    </editor>
    <abstract>
      <para>This is the DocBook/XML version of the TTCN-3 BNF taken
      from ETSI standard ETSI ES 201 873-1 V2.2.1 (2003-02)
      <citetitle>Methods for Testing and Specification (MTS); The
      Testing and Test Control Notation version 3; Part 1: TTCN-3 Core
      Language</citetitle></para>
    </abstract>
  </articleinfo>
  <productionset>
    <title>0 TTCN module</title>
    <production id="TTCN3Module">
      <lhs>TTCN3Module</lhs>
      <rhs><nonterminal
      def="#TTCN3ModuleKeyword">TTCN3ModuleKeyword</nonterminal>
      <nonterminal def="#TTCN3ModuleId">TTCN3ModuleId</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      [<nonterminal
      def="#ModuleDefinitionsPart">ModuleDefinitionsPart</nonterminal>]
      [<nonterminal
      def="#ModuleControlPart">ModuleControlPart</nonterminal>]
      <nonterminal def="#EndChar">EndChar</nonterminal> [<nonterminal
      def="#WithStatement">WithStatement</nonterminal>]</rhs>
    </production>
    <production id="TTCN3ModuleKeyword">
      <lhs>TTCN3ModuleKeyword</lhs>
      <rhs>"module"</rhs>
    </production>
    <production id="TTCN3ModuleId">
      <lhs>TTCN3ModuleId</lhs>
      <rhs><nonterminal
      def="#ModuleIdentifier">ModuleIdentifier</nonterminal>
      [<nonterminal
      def="#DefinitiveIdentifier">DefinitiveIdentifier</nonterminal>]</rhs>
    </production>
    <production id="ModuleIdentifier">
      <lhs>ModuleIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="DefinitiveIdentifier">
      <lhs>DefinitiveIdentifier</lhs>
      <rhs><nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#ObjectIdentifierKeyword">ObjectIdentifierKeyword</nonterminal>
      "{" <nonterminal
      def="#DefinitiveObjIdComponentList">DefinitiveObjIdComponentList</nonterminal>
      "}"</rhs>
    </production>
    <production id="DefinitiveObjIdComponentList">
      <lhs>DefinitiveObjIdComponentList</lhs>
      <rhs>{<nonterminal
      def="#DefinitiveObjIdComponent">DefinitiveObjIdComponent</nonterminal>}+</rhs>
    </production>
    <production id="DefinitiveObjIdComponent">
      <lhs>DefinitiveObjIdComponent</lhs>
      <rhs><nonterminal def="#NameForm">NameForm</nonterminal> |<sbr/>
      <nonterminal
      def="#DefinitiveNumberForm">DefinitiveNumberForm</nonterminal>
      |<sbr/> <nonterminal
      def="#DefinitiveNameAndNumberForm">DefinitiveNameAndNumberForm</nonterminal></rhs>
    </production>
    <production id="DefinitiveNumberForm">
      <lhs>DefinitiveNumberForm</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal></rhs>
    </production>
    <production id="DefinitiveNameAndNumberForm">
      <lhs>DefinitiveNameAndNumberForm</lhs>
      <rhs><nonterminal def="#Identifier">Identifier</nonterminal> "("
      <nonterminal
      def="#DefinitiveNumberForm">DefinitiveNumberForm</nonterminal>
      ")"</rhs>
    </production>
  </productionset>
  <productionset>
    <title>1 Module definitions part - 1.0 General</title>
    <production id="ModuleDefinitionsPart">
      <lhs>ModuleDefinitionsPart</lhs>
      <rhs><nonterminal
      def="#ModuleDefinitionsList">ModuleDefinitionsList</nonterminal></rhs>
    </production>
    <production id="ModuleDefinitionsList">
      <lhs>ModuleDefinitionsList</lhs>
      <rhs>{<nonterminal
      def="#ModuleDefinition">ModuleDefinition</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+</rhs>
    </production>
    <production id="ModuleDefinition">
      <lhs>ModuleDefinition</lhs>
      <rhs>(<nonterminal def="#TypeDef">TypeDef</nonterminal> |<sbr/>
      <nonterminal def="#ConstDef">ConstDef</nonterminal> |<sbr/>
      <nonterminal def="#TemplateDef">TemplateDef</nonterminal>
      |<sbr/> <nonterminal
      def="#ModuleParDef">ModuleParDef</nonterminal> |<sbr/>
      <nonterminal def="#FunctionDef">FunctionDef</nonterminal>
      |<sbr/> <nonterminal
      def="#SignatureDef">SignatureDef</nonterminal> |<sbr/>
      <nonterminal def="#TestcaseDef">TestcaseDef</nonterminal>
      |<sbr/> <nonterminal def="#AltstepDef">AltstepDef</nonterminal>
      |<sbr/> <nonterminal def="#ImportDef">ImportDef</nonterminal>
      |<sbr/> <nonterminal def="#GroupDef">GroupDef</nonterminal>
      |<sbr/> <nonterminal
      def="#ExtFunctionDef">ExtFunctionDef</nonterminal> |<sbr/>
      <nonterminal def="#ExtConstDef">ExtConstDef</nonterminal>)
      [<nonterminal
      def="#WithStatement">WithStatement</nonterminal>]</rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.1 Typedef definitions</title>
    <production id="TypeDef">
      <lhs>TypeDef</lhs>
      <rhs><nonterminal
      def="#TypeDefKeyword">TypeDefKeyword</nonterminal> <nonterminal
      def="#TypeDefBody">TypeDefBody</nonterminal></rhs>
    </production>
    <production id="TypeDefBody">
      <lhs>TypeDefBody</lhs>
      <rhs><nonterminal
      def="#StructuredTypeDef">StructuredTypeDef</nonterminal> |<sbr/>
      <nonterminal def="#SubTypeDef">SubTypeDef</nonterminal></rhs>
    </production>
    <production id="TypeDefKeyword">
      <lhs>TypeDefKeyword</lhs>
      <rhs>"type"</rhs>
    </production>
    <production id="StructuredTypeDef">
      <lhs>StructuredTypeDef</lhs>
      <rhs><nonterminal def="#RecordDef">RecordDef</nonterminal>
      |<sbr/> <nonterminal def="#UnionDef">UnionDef</nonterminal>
      |<sbr/> <nonterminal def="#SetDef">SetDef</nonterminal> |<sbr/>
      <nonterminal def="#RecordOfDef">RecordOfDef</nonterminal>
      |<sbr/> <nonterminal def="#SetOfDef">SetOfDef</nonterminal>
      |<sbr/> <nonterminal def="#EnumDef">EnumDef</nonterminal>
      |<sbr/> <nonterminal def="#PortDef">PortDef</nonterminal>
      |<sbr/> <nonterminal
      def="#ComponentDef">ComponentDef</nonterminal></rhs>
    </production>
    <production id="RecordDef">
      <lhs>RecordDef</lhs>
      <rhs><nonterminal
      def="#RecordKeyword">RecordKeyword</nonterminal> <nonterminal
      def="#StructDefBody">StructDefBody</nonterminal></rhs>
    </production>
    <production id="RecordKeyword">
      <lhs>RecordKeyword</lhs>
      <rhs>"record"</rhs>
    </production>
    <production id="StructDefBody">
      <lhs>StructDefBody</lhs>
      <rhs>(<nonterminal
      def="#StructTypeIdentifier">StructTypeIdentifier</nonterminal>
      [<nonterminal
      def="#StructDefFormalParList">StructDefFormalParList</nonterminal>]
      |<sbr/> <nonterminal
      def="#AddressKeyword">AddressKeyword</nonterminal>) <nonterminal
      def="#BeginChar">BeginChar</nonterminal> [<nonterminal
      def="#StructFieldDef">StructFieldDef</nonterminal> {","
      <nonterminal
       def="#StructFieldDef">StructFieldDef</nonterminal>}]
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="StructTypeIdentifier">
      <lhs>StructTypeIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="StructDefFormalParList">
      <lhs>StructDefFormalParList</lhs>
      <rhs>"(" <nonterminal
      def="#StructDefFormalPar">StructDefFormalPar</nonterminal> {","
      <nonterminal
       def="#StructDefFormalPar">StructDefFormalPar</nonterminal>}
      ")"</rhs>
    </production>
    <production id="StructDefFormalPar">
      <lhs>StructDefFormalPar</lhs>
      <rhs><nonterminal
      def="#FormalValuePar">FormalValuePar</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#FormalValuePar">FormalValuePar</nonterminal>
      shall resolve to an in parameter</lineannotation></rhs>
    </production>
    <production id="StructFieldDef">
      <lhs>StructFieldDef</lhs>
      <rhs><nonterminal def="#Type">Type</nonterminal> <nonterminal
      def="#StructFieldIdentifier">StructFieldIdentifier</nonterminal>
      [<nonterminal def="#ArrayDef">ArrayDef</nonterminal>]
      [<nonterminal def="#SubTypeSpec">SubTypeSpec</nonterminal>]
      [<nonterminal
      def="#OptionalKeyword">OptionalKeyword</nonterminal>]</rhs>
    </production>
    <production id="StructFieldIdentifier">
      <lhs>StructFieldIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="OptionalKeyword">
      <lhs>OptionalKeyword</lhs>
      <rhs>"optional"</rhs>
    </production>
    <production id="UnionDef">
      <lhs>UnionDef</lhs>
      <rhs><nonterminal def="#UnionKeyword">UnionKeyword</nonterminal>
      <nonterminal
      def="#UnionDefBody">UnionDefBody</nonterminal></rhs>
    </production>
    <production id="UnionKeyword">
      <lhs>UnionKeyword</lhs>
      <rhs>"union"</rhs>
    </production>
    <production id="UnionDefBody">
      <lhs>UnionDefBody</lhs>
      <rhs>(<nonterminal
      def="#StructTypeIdentifier">StructTypeIdentifier</nonterminal>
      [<nonterminal
      def="#StructDefFormalParList">StructDefFormalParList</nonterminal>]
      |<sbr/> <nonterminal
      def="#AddressKeyword">AddressKeyword</nonterminal>) <nonterminal
      def="#BeginChar">BeginChar</nonterminal> <nonterminal
      def="#UnionFieldDef">UnionFieldDef</nonterminal> {","
      <nonterminal def="#UnionFieldDef">UnionFieldDef</nonterminal>}
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="UnionFieldDef">
      <lhs>UnionFieldDef</lhs>
      <rhs><nonterminal def="#Type">Type</nonterminal> <nonterminal
      def="#StructFieldIdentifier">StructFieldIdentifier</nonterminal>
      [<nonterminal def="#ArrayDef">ArrayDef</nonterminal>]
      [<nonterminal
      def="#SubTypeSpec">SubTypeSpec</nonterminal>]</rhs>
    </production>
    <production id="SetDef">
      <lhs>SetDef</lhs>
      <rhs><nonterminal def="#SetKeyword">SetKeyword</nonterminal>
      <nonterminal
      def="#StructDefBody">StructDefBody</nonterminal></rhs>
    </production>
    <production id="SetKeyword">
      <lhs>SetKeyword</lhs>
      <rhs>"set"</rhs>
    </production>
    <production id="RecordOfDef">
      <lhs>RecordOfDef</lhs>
      <rhs><nonterminal
      def="#RecordKeyword">RecordKeyword</nonterminal> [<nonterminal
      def="#StringLength">StringLength</nonterminal>] <nonterminal
      def="#OfKeyword">OfKeyword</nonterminal> <nonterminal
      def="#StructOfDefBody">StructOfDefBody</nonterminal></rhs>
    </production>
    <production id="OfKeyword">
      <lhs>OfKeyword</lhs>
      <rhs>"of"</rhs>
    </production>
    <production id="StructOfDefBody">
      <lhs>StructOfDefBody</lhs>
      <rhs><nonterminal def="#Type">Type</nonterminal> (<nonterminal
      def="#StructTypeIdentifier">StructTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#AddressKeyword">AddressKeyword</nonterminal>)
      [<nonterminal
      def="#SubTypeSpec">SubTypeSpec</nonterminal>]</rhs>
    </production>
    <production id="SetOfDef">
      <lhs>SetOfDef</lhs>
      <rhs><nonterminal def="#SetKeyword">SetKeyword</nonterminal>
      [<nonterminal def="#StringLength">StringLength</nonterminal>]
      <nonterminal def="#OfKeyword">OfKeyword</nonterminal>
      <nonterminal
      def="#StructOfDefBody">StructOfDefBody</nonterminal></rhs>
    </production>
    <production id="EnumDef">
      <lhs>EnumDef</lhs>
      <rhs><nonterminal def="#EnumKeyword">EnumKeyword</nonterminal>
      (<nonterminal
      def="#EnumTypeIdentifier">EnumTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#AddressKeyword">AddressKeyword</nonterminal>)
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      <nonterminal
      def="#EnumerationList">EnumerationList</nonterminal>
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="EnumKeyword">
      <lhs>EnumKeyword</lhs>
      <rhs>"enumerated"</rhs>
    </production>
    <production id="EnumTypeIdentifier">
      <lhs>EnumTypeIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="EnumerationList">
      <lhs>EnumerationList</lhs>
      <rhs><nonterminal def="#Enumeration">Enumeration</nonterminal>
      {"," <nonterminal
      def="#Enumeration">Enumeration</nonterminal>}</rhs>
    </production>
    <production id="Enumeration">
      <lhs>Enumeration</lhs>
      <rhs><nonterminal
      def="#EnumerationIdentifier">EnumerationIdentifier</nonterminal>
      ["(" <nonterminal def="#Number">Number</nonterminal>
      ")"]</rhs>
    </production>
    <production id="EnumerationIdentifier">
      <lhs>EnumerationIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="SubTypeDef">
      <lhs>SubTypeDef</lhs>
      <rhs><nonterminal def="#Type">Type</nonterminal> (<nonterminal
      def="#SubTypeIdentifier">SubTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#AddressKeyword">AddressKeyword</nonterminal>)
      [<nonterminal def="#ArrayDef">ArrayDef</nonterminal>]
      [<nonterminal
      def="#SubTypeSpec">SubTypeSpec</nonterminal>]</rhs>
    </production>
    <production id="SubTypeIdentifier">
      <lhs>SubTypeIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="SubTypeSpec">
      <lhs>SubTypeSpec</lhs>
      <rhs><nonterminal
      def="#AllowedValues">AllowedValues</nonterminal> |<sbr/>
      <nonterminal def="#StringLength">StringLength</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#AllowedValues">AllowedValues</nonterminal>
      shall be of the same type as the field being
      subtyped</lineannotation></rhs>
    </production>
    <production id="AllowedValues">
      <lhs>AllowedValues</lhs>
      <rhs>"(" <nonterminal
      def="#ValueOrRange">ValueOrRange</nonterminal> {","
      <nonterminal def="#ValueOrRange">ValueOrRange</nonterminal>}
      ")"</rhs>
    </production>
    <production id="ValueOrRange">
      <lhs>ValueOrRange</lhs>
      <rhs><nonterminal def="#RangeDef">RangeDef</nonterminal> |<sbr/>
      <nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#RangeDef">RangeDef</nonterminal> production
      shall only be used with <link
      linkend="tt_integer">integer</link>, <link
      linkend="tt_char">char</link>, <link
      linkend="tt_universal_char">universal char</link>,
      <link linkend="tt_charstring">charstring</link>, <link
      linkend="tt_universal_charstring">universal charstring</link> or
      <link linkend="tt_float">float</link> based
      types</lineannotation> <lineannotation><emphasis>Static
      semantics</emphasis>: When subtyping charstring or universal
      charstring range and values shall not be mixed in the same
      <nonterminal
      def="#SubTypeSpec">SubTypeSpec</nonterminal></lineannotation></rhs>
    </production>
    <production id="RangeDef">
      <lhs>RangeDef</lhs>
      <rhs><nonterminal def="#LowerBound">LowerBound</nonterminal>
      ".." <nonterminal
      def="#UpperBound">UpperBound</nonterminal></rhs>
    </production>
    <production id="StringLength">
      <lhs>StringLength</lhs>
      <rhs><nonterminal
      def="#LengthKeyword">LengthKeyword</nonterminal> "("
      <nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      [".." <nonterminal def="#UpperBound">UpperBound</nonterminal>]
      ")" <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#StringLength">StringLength</nonterminal>
      shall only be used with String types or to limit set of and
      record of.  <nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      and <nonterminal def="#UpperBound">UpperBound</nonterminal>
      shall evaluate to non-negative integer values (in case of
      <nonterminal def="#UpperBound">UpperBound</nonterminal>
      including infinity)</lineannotation></rhs>
    </production>
    <production id="LengthKeyword">
      <lhs>LengthKeyword</lhs>
      <rhs>"length"</rhs>
    </production>
    <production id="PortType">
      <lhs>PortType</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal>] <nonterminal
      def="#PortTypeIdentifier">PortTypeIdentifier</nonterminal></rhs>
    </production>
    <production id="PortDef">
      <lhs>PortDef</lhs>
      <rhs><nonterminal def="#PortKeyword">PortKeyword</nonterminal>
      <nonterminal
      def="#PortDefBody">PortDefBody</nonterminal></rhs>
    </production>
    <production id="PortDefBody">
      <lhs>PortDefBody</lhs>
      <rhs><nonterminal
      def="#PortTypeIdentifier">PortTypeIdentifier</nonterminal>
      <nonterminal
      def="#PortDefAttribs">PortDefAttribs</nonterminal></rhs>
    </production>
    <production id="PortKeyword">
      <lhs>PortKeyword</lhs>
      <rhs>"port"</rhs>
    </production>
    <production id="PortTypeIdentifier">
      <lhs>PortTypeIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="PortDefAttribs">
      <lhs>PortDefAttribs</lhs>
      <rhs><nonterminal
      def="#MessageAttribs">MessageAttribs</nonterminal> |<sbr/>
      <nonterminal
       def="#ProcedureAttribs">ProcedureAttribs</nonterminal> |<sbr/>
       <nonterminal
      def="#MixedAttribs">MixedAttribs</nonterminal></rhs>
    </production>
    <production id="MessageAttribs">
      <lhs>MessageAttribs</lhs>
      <rhs><nonterminal
      def="#MessageKeyword">MessageKeyword</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      {<nonterminal def="#MessageList">MessageList</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="MessageList">
      <lhs>MessageList</lhs>
      <rhs><nonterminal def="#Direction">Direction</nonterminal>
      <nonterminal
      def="#AllOrTypeList">AllOrTypeList</nonterminal></rhs>
    </production>
    <production id="Direction">
      <lhs>Direction</lhs>
      <rhs><nonterminal
      def="#InParKeyword">InParKeyword</nonterminal> |<sbr/>
      <nonterminal def="#OutParKeyword">OutParKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#InOutParKeyword">InOutParKeyword</nonterminal></rhs>
    </production>
    <production id="MessageKeyword">
      <lhs>MessageKeyword</lhs>
      <rhs>"message"</rhs>
    </production>
    <production id="AllOrTypeList">
      <lhs>AllOrTypeList</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#TypeList">TypeList</nonterminal></rhs>
    </production>
    <production id="AllKeyword">
      <lhs>AllKeyword</lhs>
      <rhs>"all"</rhs>
    </production>
    <production id="TypeList">
      <lhs>TypeList</lhs>
      <rhs><nonterminal def="#Type">Type</nonterminal> {","
      <nonterminal def="#Type">Type</nonterminal>}</rhs>
    </production>
    <production id="ProcedureAttribs">
      <lhs>ProcedureAttribs</lhs>
      <rhs><nonterminal
      def="#ProcedureKeyword">ProcedureKeyword</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      {<nonterminal def="#ProcedureList">ProcedureList</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="ProcedureKeyword">
      <lhs>ProcedureKeyword</lhs>
      <rhs>"procedure"</rhs>
    </production>
    <production id="ProcedureList">
      <lhs>ProcedureList</lhs>
      <rhs><nonterminal def="#Direction">Direction</nonterminal>
      <nonterminal
      def="#AllOrSignatureList">AllOrSignatureList</nonterminal></rhs>
    </production>
    <production id="AllOrSignatureList">
      <lhs>AllOrSignatureList</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#SignatureList">SignatureList</nonterminal></rhs>
    </production>
    <production id="SignatureList">
      <lhs>SignatureList</lhs>
      <rhs><nonterminal def="#Signature">Signature</nonterminal>
      {"," <nonterminal
      def="#Signature">Signature</nonterminal>}</rhs>
    </production>
    <production id="MixedAttribs">
      <lhs>MixedAttribs</lhs>
      <rhs><nonterminal
      def="#MixedKeyword">MixedKeyword</nonterminal> <nonterminal
      def="#BeginChar">BeginChar</nonterminal> {<nonterminal
      def="#MixedList">MixedList</nonterminal> [<nonterminal
      def="#SemiColon">SemiColon</nonterminal>]}+ <nonterminal
      def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="MixedKeyword">
      <lhs>MixedKeyword</lhs>
      <rhs>"mixed"</rhs>
    </production>
    <production id="MixedList">
      <lhs>MixedList</lhs>
      <rhs><nonterminal def="#Direction">Direction</nonterminal>
      <nonterminal
      def="#ProcOrTypeList">ProcOrTypeList</nonterminal></rhs>
    </production>
    <production id="ProcOrTypeList">
      <lhs>ProcOrTypeList</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      |<sbr/> (<nonterminal
      def="#ProcOrType">ProcOrType</nonterminal> {"," <nonterminal
      def="#ProcOrType">ProcOrType</nonterminal>})</rhs>
    </production>
    <production id="ProcOrType">
      <lhs>ProcOrType</lhs>
      <rhs><nonterminal def="#Signature">Signature</nonterminal>
      |<sbr/> <nonterminal def="#Type">Type</nonterminal></rhs>
    </production>
    <production id="ComponentDef">
      <lhs>ComponentDef</lhs>
      <rhs><nonterminal
      def="#ComponentKeyword">ComponentKeyword</nonterminal>
      <nonterminal
      def="#ComponentTypeIdentifier">ComponentTypeIdentifier</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      [<nonterminal
      def="#ComponentDefList">ComponentDefList</nonterminal>]
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="ComponentKeyword">
      <lhs>ComponentKeyword</lhs>
      <rhs>"component"</rhs>
    </production>
    <production id="ComponentType">
      <lhs>ComponentType</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal>] <nonterminal
      def="#ComponentTypeIdentifier">ComponentTypeIdentifier</nonterminal></rhs>
    </production>
    <production id="ComponentTypeIdentifier">
      <lhs>ComponentTypeIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="ComponentDefList">
      <lhs>ComponentDefList</lhs>
      <rhs>{<nonterminal
      def="#ComponentElementDef">ComponentElementDef</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}</rhs>
    </production>
    <production id="ComponentElementDef">
      <lhs>ComponentElementDef</lhs>
      <rhs><nonterminal
      def="#PortInstance">PortInstance</nonterminal> |<sbr/>
      <nonterminal def="#VarInstance">VarInstance</nonterminal>
      |<sbr/> <nonterminal
      def="#TimerInstance">TimerInstance</nonterminal> |<sbr/>
      <nonterminal def="#ConstDef">ConstDef</nonterminal></rhs>
    </production>
    <production id="PortInstance">
      <lhs>PortInstance</lhs>
      <rhs><nonterminal def="#PortKeyword">PortKeyword</nonterminal>
      <nonterminal def="#PortType">PortType</nonterminal>
      <nonterminal def="#PortElement">PortElement</nonterminal> {","
      <nonterminal
      def="#PortElement">PortElement</nonterminal>}</rhs>
    </production>
    <production id="PortElement">
      <lhs>PortElement</lhs>
      <rhs><nonterminal
      def="#PortIdentifier">PortIdentifier</nonterminal>
      [<nonterminal def="#ArrayDef">ArrayDef</nonterminal>]</rhs>
    </production>
    <production id="PortIdentifier">
      <lhs>PortIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.2 Constant definitions</title>
    <production id="ConstDef">
      <lhs>ConstDef</lhs>
      <rhs><nonterminal def="#ConstKeyword">ConstKeyword</nonterminal>
      <nonterminal def="#Type">Type</nonterminal> <nonterminal
      def="#ConstList">ConstList</nonterminal></rhs>
    </production>
    <production id="ConstList">
      <lhs>ConstList</lhs>
      <rhs><nonterminal
      def="#SingleConstDef">SingleConstDef</nonterminal> {","
      <nonterminal
      def="#SingleConstDef">SingleConstDef</nonterminal>}</rhs>
    </production>
    <production id="SingleConstDef">
      <lhs>SingleConstDef</lhs>
      <rhs><nonterminal
      def="#ConstIdentifier">ConstIdentifier</nonterminal>
      [<nonterminal def="#ArrayDef">ArrayDef</nonterminal>]
      <nonterminal def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: The
      Value of the <nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal> shall
      be of the same type as the stated type for the
      constants</lineannotation></rhs>
    </production>
    <production id="ConstKeyword">
      <lhs>ConstKeyword</lhs>
      <rhs>"const"</rhs>
    </production>
    <production id="ConstIdentifier">
      <lhs>ConstIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.3 Template definitions</title>
    <production id="TemplateDef">
      <lhs>TemplateDef</lhs>
      <rhs><nonterminal
      def="#TemplateKeyword">TemplateKeyword</nonterminal>
      <nonterminal def="#BaseTemplate">BaseTemplate</nonterminal>
      [<nonterminal def="#DerivedDef">DerivedDef</nonterminal>]
      <nonterminal def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal
      def="#TemplateBody">TemplateBody</nonterminal></rhs>
    </production>
    <production id="BaseTemplate">
      <lhs>BaseTemplate</lhs>
      <rhs>(<nonterminal def="#Type">Type</nonterminal> |<sbr/>
      <nonterminal def="#Signature">Signature</nonterminal>)
      <nonterminal
       def="#TemplateIdentifier">TemplateIdentifier</nonterminal> ["("
       <nonterminal
       def="#TemplateFormalParList">TemplateFormalParList</nonterminal>
      ")"]</rhs>
    </production>
    <production id="TemplateKeyword">
      <lhs>TemplateKeyword</lhs>
      <rhs>"template"</rhs>
    </production>
    <production id="TemplateIdentifier">
      <lhs>TemplateIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="DerivedDef">
      <lhs>DerivedDef</lhs>
      <rhs><nonterminal
      def="#ModifiesKeyword">ModifiesKeyword</nonterminal>
      <nonterminal def="#TemplateRef">TemplateRef</nonterminal></rhs>
    </production>
    <production id="ModifiesKeyword">
      <lhs>ModifiesKeyword</lhs>
      <rhs>"modifies"</rhs>
    </production>
    <production id="TemplateFormalParList">
      <lhs>TemplateFormalParList</lhs>
      <rhs><nonterminal
      def="#TemplateFormalPar">TemplateFormalPar</nonterminal> {","
      <nonterminal
      def="#TemplateFormalPar">TemplateFormalPar</nonterminal>}</rhs>
    </production>
    <production id="TemplateFormalPar">
      <lhs>TemplateFormalPar</lhs>
      <rhs><nonterminal
      def="#FormalValuePar">FormalValuePar</nonterminal> |<sbr/>
      <nonterminal
      def="#FormalTemplatePar">FormalTemplatePar</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#FormalValuePar">FormalValuePar</nonterminal>
      shall resolve to an in parameter</lineannotation></rhs>
    </production>
    <production id="TemplateBody">
      <lhs>TemplateBody</lhs>
      <rhs><nonterminal def="#SimpleSpec">SimpleSpec</nonterminal>
      |<sbr/> <nonterminal
      def="#FieldSpecList">FieldSpecList</nonterminal> |<sbr/>
      <nonterminal
      def="#ArrayValueOrAttrib">ArrayValueOrAttrib</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: Within
      <nonterminal def="#TemplateBody">TemplateBody</nonterminal> the
      <nonterminal
      def="#ArrayValueOrAttrib">ArrayValueOrAttrib</nonterminal> can
      be used for array, record, record of and set of
      types.</lineannotation></rhs>
    </production>
    <production id="SimpleSpec">
      <lhs>SimpleSpec</lhs>
      <rhs><nonterminal
      def="#SingleValueOrAttrib">SingleValueOrAttrib</nonterminal></rhs>
    </production>
    <production id="FieldSpecList">
      <lhs>FieldSpecList</lhs>
      <rhs>"{"[<nonterminal def="#FieldSpec">FieldSpec</nonterminal>
      {"," <nonterminal def="#FieldSpec">FieldSpec</nonterminal>}]
      "}"</rhs>
    </production>
    <production id="FieldSpec">
      <lhs>FieldSpec</lhs>
      <rhs><nonterminal
      def="#FieldReference">FieldReference</nonterminal> <nonterminal
      def="#AssignmentChar">AssignmentChar</nonterminal> <nonterminal
      def="#TemplateBody">TemplateBody</nonterminal></rhs>
    </production>
    <production id="FieldReference">
      <lhs>FieldReference</lhs>
      <rhs><nonterminal
      def="#StructFieldRef">StructFieldRef</nonterminal> |<sbr/>
      <nonterminal def="#ArrayOrBitRef">ArrayOrBitRef</nonterminal>
      |<sbr/> <nonterminal def="#ParRef">ParRef</nonterminal></rhs>
    </production>
    <production id="StructFieldRef">
      <lhs>StructFieldRef</lhs>
      <rhs><nonterminal
      def="#StructFieldIdentifier">StructFieldIdentifier</nonterminal></rhs>
    </production>
    <production id="ParRef">
      <lhs>ParRef</lhs>
      <rhs><nonterminal
      def="#SignatureParIdentifier">SignatureParIdentifier</nonterminal>
      <lineannotation><emphasis>Operational semantics</emphasis>:
      <nonterminal
      def="#SignatureParIdentifier">SignatureParIdentifier</nonterminal>
      shall be a formal parameter Identifier from the associated
      signature definition</lineannotation></rhs>
    </production>
    <production id="SignatureParIdentifier">
      <lhs>SignatureParIdentifier</lhs>
      <rhs><nonterminal
      def="#ValueParIdentifier">ValueParIdentifier</nonterminal></rhs>
    </production>
    <production id="ArrayOrBitRef">
      <lhs>ArrayOrBitRef</lhs> <rhs>"[" <nonterminal
      def="#FieldOrBitNumber">FieldOrBitNumber</nonterminal> "]"
      <lineannotation><emphasis>Static semantics</emphasis>: ArrayRef
      (<nonterminal def="#ArrayOrBitRef">ArrayOrBitRef</nonterminal>?)
      shall be optionally used for array types and ASN.1 SET OF and
      SEQUENCE OF and TTCN record of and set of. The same notation can
      be used for a Bit reference inside an ASN.1 or TTCN bitstring
      type</lineannotation></rhs>
    </production>
    <production id="FieldOrBitNumber">
      <lhs>FieldOrBitNumber</lhs>
      <rhs><nonterminal
      def="#SingleExpression">SingleExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal
      def="#SingleExpression">SingleExpression</nonterminal> will
      resolve to a value of integer type</lineannotation></rhs>
    </production>
    <production id="SingleValueOrAttrib">
      <lhs>SingleValueOrAttrib</lhs>
      <rhs><nonterminal
      def="#MatchingSymbol">MatchingSymbol</nonterminal> [<nonterminal
      def="#ExtraMatchingAttributes">ExtraMatchingAttributes</nonterminal>]
      |<sbr/> <nonterminal
      def="#SingleExpression">SingleExpression</nonterminal>
      [<nonterminal
      def="#ExtraMatchingAttributes">ExtraMatchingAttributes</nonterminal>]
      |<sbr/> <nonterminal
      def="#TemplateRefWithParList">TemplateRefWithParList</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      VariableIdentifier (accessed
      via <nonterminal
      def="#SingleExpression">SingleExpression</nonterminal>) may only
      be used in inline template definitions to reference variables in
      the current scope</lineannotation></rhs>
    </production>
    <production id="ArrayValueOrAttrib">
      <lhs>ArrayValueOrAttrib</lhs>
      <rhs>"{" <nonterminal
      def="#ArrayElementSpecList">ArrayElementSpecList</nonterminal>
      "}"</rhs>
    </production>
    <production id="ArrayElementSpecList">
      <lhs>ArrayElementSpecList</lhs>
      <rhs><nonterminal
      def="#ArrayElementSpec">ArrayElementSpec</nonterminal> {","
      <nonterminal
      def="#ArrayElementSpec">ArrayElementSpec</nonterminal>}</rhs>
    </production>
    <production id="ArrayElementSpec">
      <lhs>ArrayElementSpec</lhs>
      <rhs><nonterminal
      def="#NotUsedSymbol">NotUsedSymbol</nonterminal> |<sbr/>
      <nonterminal
      def="#TemplateBody">TemplateBody</nonterminal></rhs>
    </production>
    <production id="NotUsedSymbol">
      <lhs>NotUsedSymbol</lhs>
      <rhs><nonterminal def="#Dash">Dash</nonterminal></rhs>
    </production>
    <production id="MatchingSymbol">
      <lhs>MatchingSymbol</lhs>
      <rhs><nonterminal def="#Complement">Complement</nonterminal>
      |<sbr/> <nonterminal def="#AnyValue">AnyValue</nonterminal>
      |<sbr/> <nonterminal def="#AnyOrOmit">AnyOrOmit</nonterminal>
      |<sbr/> <nonterminal
      def="#ValueOrAttribList">ValueOrAttribList</nonterminal> |<sbr/>
      <nonterminal def="#Range">Range</nonterminal> |<sbr/>
      <nonterminal def="#BitStringMatch">BitStringMatch</nonterminal>
      |<sbr/> <nonterminal
      def="#HexStringMatch">HexStringMatch</nonterminal> |<sbr/>
      <nonterminal
       def="#OctetStringMatch">OctetStringMatch</nonterminal> |<sbr/>
       <nonterminal
	def="#CharStringMatch">CharStringMatch</nonterminal> |<sbr/>
	<nonterminal def="#SubsetMatch">SubsetMatch</nonterminal>
	|<sbr/> <nonterminal
      def="#SupersetMatch">SupersetMatch</nonterminal></rhs>
    </production>
    <production id="ExtraMatchingAttributes">
      <lhs>ExtraMatchingAttributes</lhs>
      <rhs><nonterminal def="#LengthMatch">LengthMatch</nonterminal>
      |<sbr/> <nonterminal
      def="#IfPresentMatch">IfPresentMatch</nonterminal> |<sbr/>
      <nonterminal def="#LengthMatch">LengthMatch</nonterminal>
      <nonterminal
      def="#IfPresentMatch">IfPresentMatch</nonterminal></rhs>
    </production>
    <production id="BitStringMatch">
      <lhs>BitStringMatch</lhs>
      <rhs>"'" {<nonterminal
      def="#BinOrMatch">BinOrMatch</nonterminal>} "'" "B"</rhs>
    </production>
    <production id="BinOrMatch">
      <lhs>BinOrMatch</lhs>
      <rhs><nonterminal def="#Bin">Bin</nonterminal> |<sbr/>
      <nonterminal def="#AnyValue">AnyValue</nonterminal> |<sbr/>
      <nonterminal def="#AnyOrOmit">AnyOrOmit</nonterminal></rhs>
    </production>
    <production id="HexStringMatch">
      <lhs>HexStringMatch</lhs>
      <rhs>"'" {<nonterminal
      def="#HexOrMatch">HexOrMatch</nonterminal>} "'" "H"</rhs>
    </production>
    <production id="HexOrMatch">
      <lhs>HexOrMatch</lhs>
      <rhs><nonterminal def="#Hex">Hex</nonterminal> |<sbr/>
      <nonterminal def="#AnyValue">AnyValue</nonterminal> |<sbr/>
      <nonterminal def="#AnyOrOmit">AnyOrOmit</nonterminal></rhs>
    </production>
    <production id="OctetStringMatch">
      <lhs>OctetStringMatch</lhs>
      <rhs>"'" {<nonterminal
      def="#OctOrMatch">OctOrMatch</nonterminal>} "'" "O"</rhs>
    </production>
    <production id="OctOrMatch">
      <lhs>OctOrMatch</lhs>
      <rhs><nonterminal def="#Oct">Oct</nonterminal> |<sbr/>
      <nonterminal def="#AnyValue">AnyValue</nonterminal> |<sbr/>
      <nonterminal def="#AnyOrOmit">AnyOrOmit</nonterminal></rhs>
    </production>
    <production id="CharStringMatch">
      <lhs>CharStringMatch</lhs>
      <rhs><nonterminal
      def="#PatternKeyword">PatternKeyword</nonterminal> <nonterminal
      def="#Cstring">Cstring</nonterminal></rhs>
    </production>
    <production id="PatternKeyword">
      <lhs>PatternKeyword</lhs>
      <rhs>"pattern"</rhs>
    </production>
    <production id="Complement">
      <lhs>Complement</lhs>
      <rhs><nonterminal
      def="#ComplementKeyword">ComplementKeyword</nonterminal>
      <nonterminal def="#ValueList">ValueList</nonterminal></rhs>
    </production>
    <production id="ComplementKeyword">
      <lhs>ComplementKeyword</lhs>
      <rhs>"complement"</rhs>
    </production>
    <production id="ValueList">
      <lhs>ValueList</lhs>
      <rhs>"(" <nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal> {","
      <nonterminal
       def="#ConstantExpression">ConstantExpression</nonterminal>}
      ")"</rhs>
    </production>
    <production id="SubsetMatch">
      <lhs>SubsetMatch</lhs>
      <rhs><nonterminal
      def="#SubsetKeyword">SubsetKeyword</nonterminal> <nonterminal
      def="#ValueList">ValueList</nonterminal>
      <lineannotation><emphasis>Static
      semantics</emphasis>: Subset matching shall only be used with
      the set of
      type</lineannotation></rhs>
    </production>
    <production id="SubsetKeyword">
      <lhs>SubsetKeyword</lhs>
      <rhs>"subset"</rhs>
    </production>
    <production id="SupersetMatch">
      <lhs>SupersetMatch</lhs>
      <rhs><nonterminal
      def="#SupersetKeyword">SupersetKeyword</nonterminal>
      <nonterminal def="#ValueList">ValueList</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: Superset
      matching shall only
      be used with the set of type</lineannotation></rhs>
    </production>
    <production id="SupersetKeyword">
      <lhs>SupersetKeyword</lhs>
      <rhs>"superset"</rhs>
    </production>
    <production id="AnyValue">
      <lhs>AnyValue</lhs>
      <rhs>"?"</rhs>
    </production>
    <production id="AnyOrOmit">
      <lhs>AnyOrOmit</lhs>
      <rhs>"*"</rhs>
    </production>
    <production id="ValueOrAttribList">
      <lhs>ValueOrAttribList</lhs>
      <rhs>"(" <nonterminal
      def="#TemplateBody">TemplateBody</nonterminal> {"," <nonterminal
      def="#TemplateBody">TemplateBody</nonterminal>}+ ")"</rhs>
    </production>
    <production id="LengthMatch">
      <lhs>LengthMatch</lhs>
      <rhs><nonterminal
      def="#StringLength">StringLength</nonterminal></rhs>
    </production>
    <production id="IfPresentMatch">
      <lhs>IfPresentMatch</lhs>
      <rhs><nonterminal
      def="#IfPresentKeyword">IfPresentKeyword</nonterminal></rhs>
    </production>
    <production id="IfPresentKeyword">
      <lhs>IfPresentKeyword</lhs>
      <rhs>"ifpresent"</rhs>
    </production>
    <production id="Range">
      <lhs>Range</lhs>
      <rhs>"(" <nonterminal def="#LowerBound">LowerBound</nonterminal>
      ".." <nonterminal def="#UpperBound">UpperBound</nonterminal>
      ")"</rhs>
    </production>
    <production id="LowerBound">
      <lhs>LowerBound</lhs>
      <rhs><nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      |<sbr/> <nonterminal def="#Minus">Minus</nonterminal>
      <nonterminal
      def="#InfinityKeyword">InfinityKeyword</nonterminal></rhs>
    </production>
    <production id="UpperBound">
      <lhs>UpperBound</lhs>
      <rhs><nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      |<sbr/> <nonterminal
      def="#InfinityKeyword">InfinityKeyword</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#LowerBound">LowerBound</nonterminal> and
      <nonterminal def="#UpperBound">UpperBound</nonterminal> shall
      evaluate to types integer, char, universal char or float. In
      case <nonterminal def="#LowerBound">LowerBound</nonterminal> or
      <nonterminal def="#UpperBound">UpperBound</nonterminal>
      evaluates to types char or universal char, only <nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      may be present</lineannotation></rhs>
    </production>
    <production id="InfinityKeyword">
      <lhs>InfinityKeyword</lhs>
      <rhs>"infinity"</rhs>
    </production>
    <production id="TemplateInstance">
      <lhs>TemplateInstance</lhs>
      <rhs><nonterminal
      def="#InLineTemplate">InLineTemplate</nonterminal></rhs>
    </production>
    <production id="TemplateRefWithParList">
      <lhs>TemplateRefWithParList</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal>] <nonterminal
      def="#TemplateIdentifier">TemplateIdentifier</nonterminal>
      [<nonterminal
      def="#TemplateActualParList">TemplateActualParList</nonterminal>]
      |<sbr/> <nonterminal
      def="#TemplateParIdentifier">TemplateParIdentifier</nonterminal></rhs>
    </production>
    <production id="TemplateRef">
      <lhs>TemplateRef</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal>] <nonterminal
      def="#TemplateIdentifier">TemplateIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#TemplateParIdentifier">TemplateParIdentifier</nonterminal></rhs>
    </production>
    <production id="InLineTemplate">
      <lhs>InLineTemplate</lhs>
      <rhs>[(<nonterminal def="#Type">Type</nonterminal> |<sbr/>
      <nonterminal def="#Signature">Signature</nonterminal>)
      <nonterminal def="#Colon">Colon</nonterminal>] [<nonterminal
      def="#DerivedDef">DerivedDef</nonterminal> <nonterminal
      def="#AssignmentChar">AssignmentChar</nonterminal>] <nonterminal
      def="#TemplateBody">TemplateBody</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: The type
      field may only be omitted when the type is implicitly
      unambigous</lineannotation></rhs>
    </production>
    <production id="TemplateActualParList">
      <lhs>TemplateActualParList</lhs>
      <rhs>"(" <nonterminal
      def="#TemplateActualPar">TemplateActualPar</nonterminal> {","
      <nonterminal
       def="#TemplateActualPar">TemplateActualPar</nonterminal>}
      ")"</rhs>
    </production>
    <production id="TemplateActualPar">
      <lhs>TemplateActualPar</lhs>
      <rhs><nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: When the
      corresponding formal parameter is not of template type the
      <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>
      production shall resolve to one or more <nonterminal
      def="#SingleExpression">SingleExpressions</nonterminal></lineannotation></rhs>
    </production>
    <production id="TemplateOps">
      <lhs>TemplateOps</lhs>
      <rhs><nonterminal def="#MatchOp">MatchOp</nonterminal> |<sbr/>
      <nonterminal def="#ValueofOp">ValueofOp</nonterminal></rhs>
    </production>
    <production id="MatchOp">
      <lhs>MatchOp</lhs>
      <rhs><nonterminal def="#MatchKeyword">MatchKeyword</nonterminal>
      "(" <nonterminal def="#Expression">Expression</nonterminal> ","
      <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>")"
      <lineannotation><emphasis>Static semantics</emphasis>: The type
      of the value returned by the expression must be the same as the
      template type and each field of the template shall resolve to a
      single value</lineannotation></rhs>
    </production>
    <production id="MatchKeyword">
      <lhs>MatchKeyword</lhs>
      <rhs>"match"</rhs>
    </production>
    <production id="ValueofOp">
      <lhs>ValueofOp</lhs>
      <rhs><nonterminal
      def="#ValueofKeyword">ValueofKeyword</nonterminal> "("
      <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>")"</rhs>
    </production>
    <production id="ValueofKeyword">
      <lhs>ValueofKeyword</lhs>
      <rhs>"valueof"</rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.4 Function definitions</title>
    <production id="FunctionDef">
      <lhs>FunctionDef</lhs>
      <rhs><nonterminal
      def="#FunctionKeyword">FunctionKeyword</nonterminal>
      <nonterminal
      def="#FunctionIdentifier">FunctionIdentifier</nonterminal>
      "("[<nonterminal
      def="#FunctionFormalParList">FunctionFormalParList</nonterminal>]
      ")" [<nonterminal def="#RunsOnSpec">RunsOnSpec</nonterminal>]
      [<nonterminal def="#ReturnType">ReturnType</nonterminal>]
      <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
    <production id="FunctionKeyword">
      <lhs>FunctionKeyword</lhs>
      <rhs>"function"</rhs>
    </production>
    <production id="FunctionIdentifier">
      <lhs>FunctionIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="FunctionFormalParList">
      <lhs>FunctionFormalParList</lhs>
      <rhs><nonterminal
      def="#FunctionFormalPar">FunctionFormalPar</nonterminal> {","
      <nonterminal
      def="#FunctionFormalPar">FunctionFormalPar</nonterminal>}</rhs>
    </production>
    <production id="FunctionFormalPar">
      <lhs>FunctionFormalPar</lhs>
      <rhs><nonterminal
      def="#FormalValuePar">FormalValuePar</nonterminal> |<sbr/>
      <nonterminal def="#FormalTimerPar">FormalTimerPar</nonterminal>
      |<sbr/> <nonterminal
      def="#FormalTemplatePar">FormalTemplatePar</nonterminal> |<sbr/>
      <nonterminal
      def="#FormalPortPar">FormalPortPar</nonterminal></rhs>
    </production>
    <production id="ReturnType">
      <lhs>ReturnType</lhs>
      <rhs><nonterminal
      def="#ReturnKeyword">ReturnKeyword</nonterminal> <nonterminal
      def="#Type">Type</nonterminal></rhs>
    </production>
    <production id="ReturnKeyword">
      <lhs>ReturnKeyword</lhs>
      <rhs>"return"</rhs>
    </production>
    <production id="RunsOnSpec">
      <lhs>RunsOnSpec</lhs>
      <rhs><nonterminal def="#RunsKeyword">RunsKeyword</nonterminal>
      <nonterminal def="#OnKeyword">OnKeyword</nonterminal>
      <nonterminal def="#ComponentType">ComponentType</nonterminal></rhs>
    </production>
    <production id="RunsKeyword">
      <lhs>RunsKeyword</lhs>
      <rhs>"runs"</rhs>
    </production>
    <production id="OnKeyword">
      <lhs>OnKeyword</lhs>
      <rhs>"on"</rhs>
    </production>
    <production id="MTCKeyword">
      <lhs>MTCKeyword</lhs>
      <rhs>"mtc"</rhs>
    </production>
    <production id="StatementBlock">
      <lhs>StatementBlock</lhs>
      <rhs><nonterminal def="#BeginChar">BeginChar</nonterminal>
      [<nonterminal
      def="#FunctionStatementOrDefList">FunctionStatementOrDefList</nonterminal>]
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="FunctionStatementOrDefList">
      <lhs>FunctionStatementOrDefList</lhs>
      <rhs>{<nonterminal
      def="#FunctionStatementOrDef">FunctionStatementOrDef</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+</rhs>
    </production>
    <production id="FunctionStatementOrDef">
      <lhs>FunctionStatementOrDef</lhs>
      <rhs><nonterminal
      def="#FunctionLocalDef">FunctionLocalDef</nonterminal> |<sbr/>
      <nonterminal
       def="#FunctionLocalInst">FunctionLocalInst</nonterminal> |<sbr/>
       <nonterminal
      def="#FunctionStatement">FunctionStatement</nonterminal></rhs>
    </production>
    <production id="FunctionLocalInst">
      <lhs>FunctionLocalInst</lhs>
      <rhs><nonterminal def="#VarInstance">VarInstance</nonterminal>
      |<sbr/> <nonterminal
      def="#TimerInstance">TimerInstance</nonterminal></rhs>
    </production>
    <production id="FunctionLocalDef">
      <lhs>FunctionLocalDef</lhs>
      <rhs><nonterminal def="#ConstDef">ConstDef</nonterminal></rhs>
    </production>
    <production id="FunctionStatement">
      <lhs>FunctionStatement</lhs>
      <rhs><nonterminal
      def="#ConfigurationStatements">ConfigurationStatements</nonterminal>
      |<sbr/> <nonterminal
      def="#TimerStatements">TimerStatements</nonterminal> |<sbr/>
      <nonterminal
      def="#CommunicationStatements">CommunicationStatements</nonterminal>
      |<sbr/> <nonterminal
      def="#BasicStatements">BasicStatements</nonterminal> |<sbr/>
      <nonterminal
      def="#BehaviourStatements">BehaviourStatements</nonterminal>
      |<sbr/> <nonterminal
      def="#VerdictStatements">VerdictStatements</nonterminal> |<sbr/>
      <nonterminal
      def="#SUTStatements">SUTStatements</nonterminal></rhs>
    </production>
    <production id="FunctionInstance">
      <lhs>FunctionInstance</lhs>
      <rhs><nonterminal def="#FunctionRef">FunctionRef</nonterminal>
      "(" [<nonterminal
      def="#FunctionActualParList">FunctionActualParList</nonterminal>]
      ")"</rhs>
    </production>
    <production id="FunctionRef">
      <lhs>FunctionRef</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal>] (<nonterminal
      def="#FunctionIdentifier">FunctionIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#ExtFunctionIdentifier">ExtFunctionIdentifier</nonterminal>
      ) |<sbr/> <nonterminal
      def="#PreDefFunctionIdentifier">PreDefFunctionIdentifier</nonterminal></rhs>
    </production>
    <production id="PreDefFunctionIdentifier">
      <lhs>PreDefFunctionIdentifier</lhs>
      <rhs><nonterminal def="#Identifier">Identifier</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: The
      <nonterminal def="#Identifier">Identifier</nonterminal> will be
      one of the <link linkend="predefined-functions">predefined
      TTCN-3 Function Identifiers</link>.</lineannotation></rhs>
    </production>
    <production id="FunctionActualParList">
      <lhs>FunctionActualParList</lhs>
      <rhs><nonterminal
      def="#FunctionActualPar">FunctionActualPar</nonterminal> {","
      <nonterminal
      def="#FunctionActualPar">FunctionActualPar</nonterminal>}</rhs>
    </production>
    <production id="FunctionActualPar">
      <lhs>FunctionActualPar</lhs>
      <rhs><nonterminal def="#TimerRef">TimerRef</nonterminal> |<sbr/>
      <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal> |<sbr/>
      <nonterminal def="#Port">Port</nonterminal> |<sbr/> <nonterminal
      def="#ComponentRef">ComponentRef</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: When the
      corresponding formal parameter is not of template type the
      <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>
      production shall resolve to one or more <nonterminal
      def="#SingleExpression">SingleExpressions</nonterminal> i.e.,
      equivalent to the <nonterminal
      def="#Expression">Expression</nonterminal>
      production</lineannotation></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.5 Signature definitions</title>
    <production id="SignatureDef">
      <lhs>SignatureDef</lhs>
      <rhs><nonterminal
      def="#SignatureKeyword">SignatureKeyword</nonterminal>
      <nonterminal
      def="#SignatureIdentifier">SignatureIdentifier</nonterminal>
      "("[<nonterminal
      def="#SignatureFormalParList">SignatureFormalParList</nonterminal>]
      ")" [<nonterminal def="#ReturnType">ReturnType</nonterminal>
      |<sbr/> <nonterminal
      def="#NoBlockKeyword">NoBlockKeyword</nonterminal>]
      [<nonterminal
      def="#ExceptionSpec">ExceptionSpec</nonterminal>]</rhs>
    </production>
    <production id="SignatureKeyword">
      <lhs>SignatureKeyword</lhs>
      <rhs>"signature"</rhs>
    </production>
    <production id="SignatureIdentifier">
      <lhs>SignatureIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="SignatureFormalParList">
      <lhs>SignatureFormalParList</lhs>
      <rhs><nonterminal
      def="#SignatureFormalPar">SignatureFormalPar</nonterminal> {","
      <nonterminal
      def="#SignatureFormalPar">SignatureFormalPar</nonterminal>}</rhs>
    </production>
    <production id="SignatureFormalPar">
      <lhs>SignatureFormalPar</lhs>
      <rhs><nonterminal
      def="#FormalValuePar">FormalValuePar</nonterminal></rhs>
    </production>
    <production id="ExceptionSpec">
      <lhs>ExceptionSpec</lhs>
      <rhs><nonterminal
      def="#ExceptionKeyword">ExceptionKeyword</nonterminal> "("
      <nonterminal
      def="#ExceptionTypeList">ExceptionTypeList</nonterminal>
      ")"</rhs>
    </production>
    <production id="ExceptionKeyword">
      <lhs>ExceptionKeyword</lhs>
      <rhs>"exception"</rhs>
    </production>
    <production id="ExceptionTypeList">
      <lhs>ExceptionTypeList</lhs>
      <rhs><nonterminal def="#Type">Type</nonterminal> {","
      <nonterminal def="#Type">Type</nonterminal>}</rhs>
    </production>
    <production id="NoBlockKeyword">
      <lhs>NoBlockKeyword</lhs>
      <rhs>"noblock"</rhs>
    </production>
    <production id="Signature">
      <lhs>Signature</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal>] <nonterminal
      def="#SignatureIdentifier">SignatureIdentifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.6 Testcase definitions</title>
    <production id="TestcaseDef">
      <lhs>TestcaseDef</lhs>
      <rhs><nonterminal
      def="#TestcaseKeyword">TestcaseKeyword</nonterminal>
      <nonterminal
      def="#TestcaseIdentifier">TestcaseIdentifier</nonterminal>
      "("[<nonterminal
      def="#TestcaseFormalParList">TestcaseFormalParList</nonterminal>]
      ")" <nonterminal def="#ConfigSpec">ConfigSpec</nonterminal>
      <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
    <production id="TestcaseKeyword">
      <lhs>TestcaseKeyword</lhs>
      <rhs>"testcase"</rhs>
    </production>
    <production id="TestcaseIdentifier">
      <lhs>TestcaseIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="TestcaseFormalParList">
      <lhs>TestcaseFormalParList</lhs>
      <rhs><nonterminal
      def="#TestcaseFormalPar">TestcaseFormalPar</nonterminal> {","
      <nonterminal
      def="#TestcaseFormalPar">TestcaseFormalPar</nonterminal>}</rhs>
    </production>
    <production id="TestcaseFormalPar">
      <lhs>TestcaseFormalPar</lhs>
      <rhs><nonterminal
      def="#FormalValuePar">FormalValuePar</nonterminal> |<sbr/>
      <nonterminal
      def="#FormalTemplatePar">FormalTemplatePar</nonterminal></rhs>
    </production>
    <production id="ConfigSpec">
      <lhs>ConfigSpec</lhs>
      <rhs><nonterminal def="#RunsOnSpec">RunsOnSpec</nonterminal>
      [<nonterminal def="#SystemSpec">SystemSpec</nonterminal>]</rhs>
    </production>
    <production id="SystemSpec">
      <lhs>SystemSpec</lhs>
      <rhs><nonterminal
      def="#SystemKeyword">SystemKeyword</nonterminal> <nonterminal
      def="#ComponentType">ComponentType</nonterminal></rhs>
    </production>
    <production id="SystemKeyword">
      <lhs>SystemKeyword</lhs>
      <rhs>"system"</rhs>
    </production>
    <production id="TestcaseInstance">
      <lhs>TestcaseInstance</lhs>
      <rhs><nonterminal
      def="#ExecuteKeyword">ExecuteKeyword</nonterminal> "("
      <nonterminal def="#TestcaseRef">TestcaseRef</nonterminal> "("
      [<nonterminal
      def="#TestcaseActualParList">TestcaseActualParList</nonterminal>]
      ")" ["," <nonterminal
      def="#TimerValue">TimerValue</nonterminal>] ")"</rhs>
    </production>
    <production id="ExecuteKeyword">
      <lhs>ExecuteKeyword</lhs>
      <rhs>"execute"</rhs>
    </production>
    <production id="TestcaseRef">
      <lhs>TestcaseRef</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal>] <nonterminal
      def="#TestcaseIdentifier">TestcaseIdentifier</nonterminal></rhs>
    </production>
    <production id="TestcaseActualParList">
      <lhs>TestcaseActualParList</lhs>
      <rhs><nonterminal
      def="#TestcaseActualPar">TestcaseActualPar</nonterminal> {","
      <nonterminal
      def="#TestcaseActualPar">TestcaseActualPar</nonterminal>}</rhs>
    </production>
    <production id="TestcaseActualPar">
      <lhs>TestcaseActualPar</lhs>
      <rhs><nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: When the
      corresponding formal parameter is not of template type the
      <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>
      production shall resolve to one or more <nonterminal
      def="#SingleExpression">SingleExpressions</nonterminal> i.e.,
      equivalent to the Expression production</lineannotation></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.7 Altstep definitions</title>
    <production id="AltstepDef">
      <lhs>AltstepDef</lhs>
      <rhs><nonterminal
      def="#AltstepKeyword">AltstepKeyword</nonterminal> <nonterminal
      def="#AltstepIdentifier">AltstepIdentifier</nonterminal>
      "("[<nonterminal
      def="#AltstepFormalParList">AltstepFormalParList</nonterminal>]
      ")" [<nonterminal def="#RunsOnSpec">RunsOnSpec</nonterminal>]
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      <nonterminal
      def="#AltstepLocalDefList">AltstepLocalDefList</nonterminal>
      <nonterminal def="#AltGuardList">AltGuardList</nonterminal>
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="AltstepKeyword">
      <lhs>AltstepKeyword</lhs>
      <rhs>"altstep"</rhs>
    </production>
    <production id="AltstepIdentifier">
      <lhs>AltstepIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="AltstepFormalParList">
      <lhs>AltstepFormalParList</lhs>
      <rhs><nonterminal
      def="#FunctionFormalParList">FunctionFormalParList</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: all
      formal parameter must be value parameters i.e., in
      parameters</lineannotation></rhs>
    </production>
    <production id="AltstepLocalDefList">
      <lhs>AltstepLocalDefList</lhs>
      <rhs>{<nonterminal
      def="#AltstepLocalDef">AltstepLocalDef</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}</rhs>
    </production>
    <production id="AltstepLocalDef">
      <lhs>AltstepLocalDef</lhs>
      <rhs><nonterminal def="#VarInstance">VarInstance</nonterminal>
      |<sbr/> <nonterminal
      def="#TimerInstance">TimerInstance</nonterminal> |<sbr/>
      <nonterminal def="#ConstDef">ConstDef</nonterminal></rhs>
    </production>
    <production id="AltstepInstance">
      <lhs>AltstepInstance</lhs>
      <rhs><nonterminal def="#AltstepRef">AltstepRef</nonterminal> "("
      [<nonterminal
      def="#FunctionActualParList">FunctionActualParList</nonterminal>]
      ")"</rhs>
    </production>
    <production id="AltstepRef">
      <lhs>AltstepRef</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal>] <nonterminal
      def="#AltstepIdentifier">AltstepIdentifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.8 Import definitions</title>
    <production id="ImportDef">
      <lhs>ImportDef</lhs>
      <rhs><nonterminal
      def="#ImportKeyword">ImportKeyword</nonterminal> <nonterminal
      def="#ImportFromSpec">ImportFromSpec</nonterminal> (<nonterminal
      def="#AllWithExcepts">AllWithExcepts</nonterminal> |<sbr/>
      (<nonterminal def="#BeginChar">BeginChar</nonterminal>
      <nonterminal def="#ImportSpec">ImportSpec</nonterminal>
      <nonterminal def="#EndChar">EndChar</nonterminal>))</rhs>
    </production>
    <production id="ImportKeyword">
      <lhs>ImportKeyword</lhs>
      <rhs>"import"</rhs>
    </production>
    <production id="AllWithExcepts">
      <lhs>AllWithExcepts</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptsDef">ExceptsDef</nonterminal>]</rhs>
    </production>
    <production id="ExceptsDef">
      <lhs>ExceptsDef</lhs>
      <rhs><nonterminal
      def="#ExceptKeyword">ExceptKeyword</nonterminal> <nonterminal
      def="#BeginChar">BeginChar</nonterminal> <nonterminal
      def="#ExceptSpec">ExceptSpec</nonterminal> <nonterminal
      def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="ExceptKeyword">
      <lhs>ExceptKeyword</lhs>
      <rhs>"except"</rhs>
    </production>
    <production id="ExceptSpec">
      <lhs>ExceptSpec</lhs>
      <rhs>{<nonterminal
      def="#ExceptElement">ExceptElement</nonterminal> [<nonterminal
      def="#SemiColon">SemiColon</nonterminal>]}
      <lineannotation><emphasis>Static semantics</emphasis>: Any of
      the production components (<nonterminal
      def="#ExceptGroupSpec">ExceptGroupSpec</nonterminal>,
      <nonterminal
      def="#ExceptTypeDefSpec">ExceptTypeDefSpec</nonterminal> etc.)
      may be present only once in the <nonterminal
      def="#ExceptSpec">ExceptSpec</nonterminal>
      production</lineannotation></rhs>
    </production>
    <production id="ExceptElement">
      <lhs>ExceptElement</lhs>
      <rhs><nonterminal
      def="#ExceptGroupSpec">ExceptGroupSpec</nonterminal> |<sbr/>
      <nonterminal
       def="#ExceptTypeDefSpec">ExceptTypeDefSpec</nonterminal> |<sbr/>
       <nonterminal
       def="#ExceptTemplateSpec">ExceptTemplateSpec</nonterminal>
       |<sbr/> <nonterminal
       def="#ExceptConstSpec">ExceptConstSpec</nonterminal> |<sbr/>
       <nonterminal
       def="#ExceptTestcaseSpec">ExceptTestcaseSpec</nonterminal>
       |<sbr/> <nonterminal
       def="#ExceptAltstepSpec">ExceptAltstepSpec</nonterminal> |<sbr/>
       <nonterminal
       def="#ExceptFunctionSpec">ExceptFunctionSpec</nonterminal>
       |<sbr/> <nonterminal
       def="#ExceptSignatureSpec">ExceptSignatureSpec</nonterminal>
       |<sbr/> <nonterminal
      def="#ExceptModuleParSpec">ExceptModuleParSpec</nonterminal></rhs>
    </production>
    <production id="ExceptGroupSpec">
      <lhs>ExceptGroupSpec</lhs>
      <rhs><nonterminal def="#GroupKeyword">GroupKeyword</nonterminal>
      (<nonterminal
      def="#ExceptGroupRefList">ExceptGroupRefList</nonterminal>
      |<sbr/> <nonterminal
      def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptTypeDefSpec">
      <lhs>ExceptTypeDefSpec</lhs>
      <rhs><nonterminal
      def="#TypeDefKeyword">TypeDefKeyword</nonterminal> (<nonterminal
      def="#TypeRefList">TypeRefList</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptTemplateSpec">
      <lhs>ExceptTemplateSpec</lhs>
      <rhs><nonterminal
      def="#TemplateKeyword">TemplateKeyword</nonterminal>
      (<nonterminal
      def="#TemplateRefList">TemplateRefList</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptConstSpec">
      <lhs>ExceptConstSpec</lhs>
      <rhs><nonterminal def="#ConstKeyword">ConstKeyword</nonterminal>
      (<nonterminal def="#ConstRefList">ConstRefList</nonterminal>
      |<sbr/> <nonterminal
      def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptTestcaseSpec">
      <lhs>ExceptTestcaseSpec</lhs>
      <rhs><nonterminal
      def="#TestcaseKeyword">TestcaseKeyword</nonterminal>
      (<nonterminal
      def="#TestcaseRefList">TestcaseRefList</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptAltstepSpec">
      <lhs>ExceptAltstepSpec</lhs>
      <rhs><nonterminal
      def="#AltstepKeyword">AltstepKeyword</nonterminal> (<nonterminal
      def="#AltstepRefList">AltstepRefList</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptFunctionSpec">
      <lhs>ExceptFunctionSpec</lhs>
      <rhs><nonterminal
      def="#FunctionKeyword">FunctionKeyword</nonterminal>
      (<nonterminal
      def="#FunctionRefList">FunctionRefList</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptSignatureSpec">
      <lhs>ExceptSignatureSpec</lhs>
      <rhs><nonterminal
      def="#SignatureKeyword">SignatureKeyword</nonterminal>
      (<nonterminal
      def="#SignatureRefList">SignatureRefList</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ExceptModuleParSpec">
      <lhs>ExceptModuleParSpec</lhs>
      <rhs><nonterminal
      def="#ModuleParKeyword">ModuleParKeyword</nonterminal>
      (<nonterminal
      def="#ModuleParRefList">ModuleParRefList</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)</rhs>
    </production>
    <production id="ImportSpec">
      <lhs>ImportSpec</lhs>
      <rhs>{<nonterminal
      def="#ImportElement">ImportElement</nonterminal> [<nonterminal
      def="#SemiColon">SemiColon</nonterminal>]}</rhs>
    </production>
    <production id="ImportElement">
      <lhs>ImportElement</lhs>
      <rhs><nonterminal
      def="#ImportGroupSpec">ImportGroupSpec</nonterminal> |<sbr/>
      <nonterminal
       def="#ImportTypeDefSpec">ImportTypeDefSpec</nonterminal> |<sbr/>
       <nonterminal
       def="#ImportTemplateSpec">ImportTemplateSpec</nonterminal>
       |<sbr/> <nonterminal
       def="#ImportConstSpec">ImportConstSpec</nonterminal> |<sbr/>
       <nonterminal
       def="#ImportTestcaseSpec">ImportTestcaseSpec</nonterminal>
       |<sbr/> <nonterminal
       def="#ImportAltstepSpec">ImportAltstepSpec</nonterminal> |<sbr/>
       <nonterminal
       def="#ImportFunctionSpec">ImportFunctionSpec</nonterminal>
       |<sbr/> <nonterminal
       def="#ImportSignatureSpec">ImportSignatureSpec</nonterminal>
       |<sbr/> <nonterminal
      def="#ImportModuleParSpec">ImportModuleParSpec</nonterminal></rhs>
    </production>
    <production id="ImportFromSpec">
      <lhs>ImportFromSpec</lhs>
      <rhs><nonterminal def="#FromKeyword">FromKeyword</nonterminal>
      <nonterminal def="#ModuleId">ModuleId</nonterminal>
      [<nonterminal
      def="#RecursiveKeyword">RecursiveKeyword</nonterminal>]</rhs>
    </production>
    <production id="ModuleId">
      <lhs>ModuleId</lhs>
      <rhs><nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> [<nonterminal
      def="#LanguageSpec">LanguageSpec</nonterminal>]
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#LanguageSpec">LanguageSpec</nonterminal> may
      only be omitted if the referenced module contains TTCN-3
      notation</lineannotation></rhs>
    </production>
    <production id="LanguageKeyword">
      <lhs>LanguageKeyword</lhs>
      <rhs>"language"</rhs>
    </production>
    <production id="LanguageSpec">
      <lhs>LanguageSpec</lhs>
      <rhs><nonterminal
      def="#LanguageKeyword">LanguageKeyword</nonterminal>
      <nonterminal def="#FreeText">FreeText</nonterminal></rhs>
    </production>
    <production id="GlobalModuleId">
      <lhs>GlobalModuleId</lhs>
      <rhs><nonterminal
      def="#ModuleIdentifier">ModuleIdentifier</nonterminal>
      [<nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#ObjectIdentifierValue">ObjectIdentifierValue</nonterminal>]</rhs>
    </production>
    <production id="RecursiveKeyword">
      <lhs>RecursiveKeyword</lhs>
      <rhs>"recursive"</rhs>
    </production>
    <production id="ImportGroupSpec">
      <lhs>ImportGroupSpec</lhs>
      <rhs><nonterminal def="#GroupKeyword">GroupKeyword</nonterminal>
      (<nonterminal def="#GroupRefList">GroupRefList</nonterminal>
      |<sbr/> <nonterminal
      def="#AllGroupsWithExcept">AllGroupsWithExcept</nonterminal>)</rhs>
    </production>
    <production id="GroupRefList">
      <lhs>GroupRefList</lhs>
      <rhs><nonterminal
      def="#FullGroupIdentifier">FullGroupIdentifier</nonterminal>
      {"," <nonterminal
      def="#FullGroupIdentifier">FullGroupIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllGroupsWithExcept">
      <lhs>AllGroupsWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#GroupRefList">GroupRefList</nonterminal>]</rhs>
    </production>
    <production id="FullGroupIdentifier">
      <lhs>FullGroupIdentifier</lhs>
      <rhs><nonterminal
      def="#GroupIdentifier">GroupIdentifier</nonterminal>
      {<nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#GroupIdentifier">GroupIdentifier</nonterminal>}
      [<nonterminal def="#ExceptsDef">ExceptsDef</nonterminal>]</rhs>
    </production>
    <production id="ExceptGroupRefList">
      <lhs>ExceptGroupRefList</lhs>
      <rhs><nonterminal
      def="#ExceptFullGroupIdentifier">ExceptFullGroupIdentifier</nonterminal>
      {"," <nonterminal
      def="#ExceptFullGroupIdentifier">ExceptFullGroupIdentifier</nonterminal>}</rhs>
    </production>
    <production id="ExceptFullGroupIdentifier">
      <lhs>ExceptFullGroupIdentifier</lhs>
      <rhs><nonterminal
      def="#GroupIdentifier">GroupIdentifier</nonterminal>
      {<nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#GroupIdentifier">GroupIdentifier</nonterminal>}</rhs>
    </production>
    <production id="ImportTypeDefSpec">
      <lhs>ImportTypeDefSpec</lhs>
      <rhs><nonterminal
      def="#TypeDefKeyword">TypeDefKeyword</nonterminal> (<nonterminal
      def="#TypeRefList">TypeRefList</nonterminal> |<sbr/>
      <nonterminal
      def="#AllTypesWithExcept">AllTypesWithExcept</nonterminal>)</rhs>
    </production>
    <production id="TypeRefList">
      <lhs>TypeRefList</lhs>
      <rhs><nonterminal
      def="#TypeDefIdentifier">TypeDefIdentifier</nonterminal> {","
      <nonterminal
      def="#TypeDefIdentifier">TypeDefIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllTypesWithExcept">
      <lhs>AllTypesWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal def="#TypeRefList">TypeRefList</nonterminal>]</rhs>
    </production>
    <production id="TypeDefIdentifier">
      <lhs>TypeDefIdentifier</lhs>
      <rhs><nonterminal
      def="#StructTypeIdentifier">StructTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#EnumTypeIdentifier">EnumTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#PortTypeIdentifier">PortTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#ComponentTypeIdentifier">ComponentTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#SubTypeIdentifier">SubTypeIdentifier</nonterminal></rhs>
    </production>
    <production id="ImportTemplateSpec">
      <lhs>ImportTemplateSpec</lhs>
      <rhs><nonterminal
      def="#TemplateKeyword">TemplateKeyword</nonterminal>
      (<nonterminal
      def="#TemplateRefList">TemplateRefList</nonterminal> |<sbr/>
      <nonterminal
      def="#AllTemplsWithExcept">AllTemplsWithExcept</nonterminal>)</rhs>
    </production>
    <production id="TemplateRefList">
      <lhs>TemplateRefList</lhs>
      <rhs><nonterminal
      def="#TemplateIdentifier">TemplateIdentifier</nonterminal> {","
      <nonterminal
      def="#TemplateIdentifier">TemplateIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllTemplsWithExcept">
      <lhs>AllTemplsWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#TemplateRefList">TemplateRefList</nonterminal>]</rhs>
    </production>
    <production id="ImportConstSpec">
      <lhs>ImportConstSpec</lhs>
      <rhs><nonterminal def="#ConstKeyword">ConstKeyword</nonterminal>
      (<nonterminal def="#ConstRefList">ConstRefList</nonterminal>
      |<sbr/> <nonterminal
      def="#AllConstsWithExcept">AllConstsWithExcept</nonterminal>)</rhs>
    </production>
    <production id="ConstRefList">
      <lhs>ConstRefList</lhs>
      <rhs><nonterminal
      def="#ConstIdentifier">ConstIdentifier</nonterminal> {","
      <nonterminal
      def="#ConstIdentifier">ConstIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllConstsWithExcept">
      <lhs>AllConstsWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#ConstRefList">ConstRefList</nonterminal>]</rhs>
    </production>
    <production id="ImportAltstepSpec">
      <lhs>ImportAltstepSpec</lhs>
      <rhs><nonterminal
      def="#AltstepKeyword">AltstepKeyword</nonterminal> (<nonterminal
      def="#AltstepRefList">AltstepRefList</nonterminal> |<sbr/>
      <nonterminal
      def="#AllAltstepsWithExcept">AllAltstepsWithExcept</nonterminal>)</rhs>
    </production>
    <production id="AltstepRefList">
      <lhs>AltstepRefList</lhs>
      <rhs><nonterminal
      def="#AltstepIdentifier">AltstepIdentifier</nonterminal> {","
      <nonterminal
      def="#AltstepIdentifier">AltstepIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllAltstepsWithExcept">
      <lhs>AllAltstepsWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#AltstepRefList">AltstepRefList</nonterminal>]</rhs>
    </production>
    <production id="ImportTestcaseSpec">
      <lhs>ImportTestcaseSpec</lhs>
      <rhs><nonterminal
      def="#TestcaseKeyword">TestcaseKeyword</nonterminal>
      (<nonterminal
      def="#TestcaseRefList">TestcaseRefList</nonterminal> |<sbr/>
      <nonterminal
      def="#AllTestcasesWithExcept">AllTestcasesWithExcept</nonterminal>)</rhs>
    </production>
    <production id="TestcaseRefList">
      <lhs>TestcaseRefList</lhs>
      <rhs><nonterminal
      def="#TestcaseIdentifier">TestcaseIdentifier</nonterminal> {","
      <nonterminal
      def="#TestcaseIdentifier">TestcaseIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllTestcasesWithExcept">
      <lhs>AllTestcasesWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#TestcaseRefList">TestcaseRefList</nonterminal>]</rhs>
    </production>
    <production id="ImportFunctionSpec">
      <lhs>ImportFunctionSpec</lhs>
      <rhs><nonterminal
      def="#FunctionKeyword">FunctionKeyword</nonterminal>
      (<nonterminal
      def="#FunctionRefList">FunctionRefList</nonterminal> |<sbr/>
      <nonterminal
      def="#AllFunctionsWithExcept">AllFunctionsWithExcept</nonterminal>)</rhs>
    </production>
    <production id="FunctionRefList">
      <lhs>FunctionRefList</lhs>
      <rhs><nonterminal
      def="#FunctionIdentifier">FunctionIdentifier</nonterminal> {","
      <nonterminal
      def="#FunctionIdentifier">FunctionIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllFunctionsWithExcept">
      <lhs>AllFunctionsWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#FunctionRefList">FunctionRefList</nonterminal>]</rhs>
    </production>
    <production id="ImportSignatureSpec">
      <lhs>ImportSignatureSpec</lhs>
      <rhs><nonterminal
      def="#SignatureKeyword">SignatureKeyword</nonterminal>
      (<nonterminal
      def="#SignatureRefList">SignatureRefList</nonterminal> |<sbr/>
      <nonterminal
      def="#AllSignaturesWithExcept">AllSignaturesWithExcept</nonterminal>)</rhs>
    </production>
    <production id="SignatureRefList">
      <lhs>SignatureRefList</lhs>
      <rhs><nonterminal
      def="#SignatureIdentifier">SignatureIdentifier</nonterminal>
      {"," <nonterminal
      def="#SignatureIdentifier">SignatureIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllSignaturesWithExcept">
      <lhs>AllSignaturesWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#SignatureRefList">SignatureRefList</nonterminal>]</rhs>
    </production>
    <production id="ImportModuleParSpec">
      <lhs>ImportModuleParSpec</lhs>
      <rhs><nonterminal
      def="#ModuleParKeyword">ModuleParKeyword</nonterminal>
      (<nonterminal
      def="#ModuleParRefList">ModuleParRefList</nonterminal> |<sbr/>
      <nonterminal
      def="#AllModuleParWithExcept">AllModuleParWithExcept</nonterminal>)</rhs>
    </production>
    <production id="ModuleParRefList">
      <lhs>ModuleParRefList</lhs>
      <rhs><nonterminal
      def="#ModuleParIdentifier">ModuleParIdentifier</nonterminal>
      {"," <nonterminal
      def="#ModuleParIdentifier">ModuleParIdentifier</nonterminal>}</rhs>
    </production>
    <production id="AllModuleParWithExcept">
      <lhs>AllModuleParWithExcept</lhs>
      <rhs><nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal
      def="#ModuleParRefList">ModuleParRefList</nonterminal>]</rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.9 Group definitions</title>
    <production id="GroupDef">
      <lhs>GroupDef</lhs>
      <rhs><nonterminal def="#GroupKeyword">GroupKeyword</nonterminal>
      <nonterminal
      def="#GroupIdentifier">GroupIdentifier</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      [<nonterminal
      def="#ModuleDefinitionsPart">ModuleDefinitionsPart</nonterminal>]
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="GroupKeyword">
      <lhs>GroupKeyword</lhs>
      <rhs>"group"</rhs>
    </production>
    <production id="GroupIdentifier">
      <lhs>GroupIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.10 External function definitions</title>
    <production id="ExtFunctionDef">
      <lhs>ExtFunctionDef</lhs>
      <rhs><nonterminal def="#ExtKeyword">ExtKeyword</nonterminal>
      <nonterminal
      def="#FunctionKeyword">FunctionKeyword</nonterminal>
      <nonterminal
      def="#ExtFunctionIdentifier">ExtFunctionIdentifier</nonterminal>
      "("[<nonterminal
      def="#FunctionFormalParList">FunctionFormalParList</nonterminal>]
      ")" [<nonterminal
      def="#ReturnType">ReturnType</nonterminal>]</rhs>
    </production>
    <production id="ExtKeyword">
      <lhs>ExtKeyword</lhs>
      <rhs>"external"</rhs>
    </production>
    <production id="ExtFunctionIdentifier">
      <lhs>ExtFunctionIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.11 External constant definitions</title>
    <production id="ExtConstDef">
      <lhs>ExtConstDef</lhs>
      <rhs><nonterminal def="#ExtKeyword">ExtKeyword</nonterminal>
      <nonterminal def="#ConstKeyword">ConstKeyword</nonterminal>
      <nonterminal def="#Type">Type</nonterminal> <nonterminal def="#ExtConstIdentifier">ExtConstIdentifier</nonterminal></rhs>
    </production>
    <production id="ExtConstIdentifier">
      <lhs>ExtConstIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>1.12 Module parameter definitions</title>
    <production id="ModuleParDef">
      <lhs>ModuleParDef</lhs>
      <rhs><nonterminal
      def="#ModuleParKeyword">ModuleParKeyword</nonterminal> "{"
      <nonterminal def="#ModuleParList">ModuleParList</nonterminal>
      "}"</rhs>
    </production>
    <production id="ModuleParKeyword">
      <lhs>ModuleParKeyword</lhs>
      <rhs>"modulepar"</rhs>
    </production>
    <production id="ModuleParList">
      <lhs>ModuleParList</lhs>
      <rhs><nonterminal def="#ModulePar">ModulePar</nonterminal>
      {<nonterminal def="#SemiColon">SemiColon</nonterminal>
      <nonterminal def="#ModulePar">ModulePar</nonterminal>}</rhs>
    </production>
    <production id="ModulePar">
      <lhs>ModulePar</lhs>
      <rhs><nonterminal
      def="#ModuleParType">ModuleParType</nonterminal> <nonterminal
      def="#ModuleParIdentifier">ModuleParIdentifier</nonterminal>
      [<nonterminal def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal>] {","
      <nonterminal
      def="#ModuleParIdentifier">ModuleParIdentifier</nonterminal>
      [<nonterminal def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal>]}
      <lineannotation><emphasis>Static semantics</emphasis>: The
      Value of the <nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal> shall
      be of the same type as the stated type for the
      Parameter</lineannotation></rhs>
    </production>
    <production id="ModuleParType">
      <lhs>ModuleParType</lhs>
      <rhs><nonterminal def="#Type">Type</nonterminal></rhs>
    </production>
    <production id="ModuleParIdentifier">
      <lhs>ModuleParIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>2 Control part - 2.0 General</title>
    <production id="ModuleControlPart">
      <lhs>ModuleControlPart</lhs>
      <rhs><nonterminal
      def="#ControlKeyword">ControlKeyword</nonterminal> <nonterminal
      def="#BeginChar">BeginChar</nonterminal> <nonterminal
      def="#ModuleControlBody">ModuleControlBody</nonterminal>
      <nonterminal def="#EndChar">EndChar</nonterminal> [<nonterminal
      def="#WithStatement">WithStatement</nonterminal>] [<nonterminal
      def="#SemiColon">SemiColon</nonterminal>]</rhs>
    </production>
    <production id="ControlKeyword">
      <lhs>ControlKeyword</lhs>
      <rhs>"control"</rhs>
    </production>
    <production id="ModuleControlBody">
      <lhs>ModuleControlBody</lhs>
      <rhs>[<nonterminal
      def="#ControlStatementOrDefList">ControlStatementOrDefList</nonterminal>]</rhs>
    </production>
    <production id="ControlStatementOrDefList">
      <lhs>ControlStatementOrDefList</lhs>
      <rhs>{<nonterminal
      def="#ControlStatementOrDef">ControlStatementOrDef</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+</rhs>
    </production>
    <production id="ControlStatementOrDef">
      <lhs>ControlStatementOrDef</lhs>
      <rhs><nonterminal
      def="#FunctionLocalInst">FunctionLocalInst</nonterminal> |<sbr/>
      <nonterminal
       def="#ControlStatement">ControlStatement</nonterminal> |<sbr/>
       <nonterminal
      def="#FunctionLocalDef">FunctionLocalDef</nonterminal></rhs>
    </production>
    <production id="ControlStatement">
      <lhs>ControlStatement</lhs>
      <rhs><nonterminal
      def="#TimerStatements">TimerStatements</nonterminal> |<sbr/>
      <nonterminal
       def="#BasicStatements">BasicStatements</nonterminal> |<sbr/>
       <nonterminal
       def="#BehaviourStatements">BehaviourStatements</nonterminal>
       |<sbr/> <nonterminal
      def="#SUTStatements">SUTStatements</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>2.1 Variable instantiation</title>
    <production id="VarInstance">
      <lhs>VarInstance</lhs>
      <rhs><nonterminal def="#VarKeyword">VarKeyword</nonterminal>
      <nonterminal def="#Type">Type</nonterminal> <nonterminal
      def="#VarList">VarList</nonterminal></rhs>
    </production>
    <production id="VarList">
      <lhs>VarList</lhs>
      <rhs><nonterminal
      def="#SingleVarInstance">SingleVarInstance</nonterminal> {","
      <nonterminal
      def="#SingleVarInstance">SingleVarInstance</nonterminal>}</rhs>
    </production>
    <production id="SingleVarInstance">
      <lhs>SingleVarInstance</lhs>
      <rhs><nonterminal
      def="#VarIdentifier">VarIdentifier</nonterminal> [<nonterminal
      def="#ArrayDef">ArrayDef</nonterminal>] [<nonterminal
      def="#AssignmentChar">AssignmentChar</nonterminal> <nonterminal
      def="#VarInitialValue">VarInitialValue</nonterminal>]</rhs>
    </production>
    <production id="VarInitialValue">
      <lhs>VarInitialValue</lhs>
      <rhs><nonterminal
      def="#Expression">Expression</nonterminal></rhs>
    </production>
    <production id="VarKeyword">
      <lhs>VarKeyword</lhs>
      <rhs>"var"</rhs>
    </production>
    <production id="VarIdentifier">
      <lhs>VarIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="VariableRef">
      <lhs>VariableRef</lhs>
      <rhs>(<nonterminal
      def="#VarIdentifier">VarIdentifier</nonterminal> |<sbr/>
      <nonterminal
       def="#ValueParIdentifier">ValueParIdentifier</nonterminal>)
       [<nonterminal
      def="#ExtendedFieldReference">ExtendedFieldReference</nonterminal>]</rhs>
    </production>
  </productionset>
  <productionset>
    <title>2.2 Timer instantiation</title>
    <production id="TimerInstance">
      <lhs>TimerInstance</lhs>
      <rhs><nonterminal def="#TimerKeyword">TimerKeyword</nonterminal>
      <nonterminal def="#TimerList">TimerList</nonterminal></rhs>
    </production>
    <production id="TimerList">
      <lhs>TimerList</lhs>
      <rhs><nonterminal
      def="#SingleTimerInstance">SingleTimerInstance</nonterminal>{","
      <nonterminal
      def="#SingleTimerInstance">SingleTimerInstance</nonterminal>}</rhs>
    </production>
    <production id="SingleTimerInstance">
      <lhs>SingleTimerInstance</lhs>
      <rhs><nonterminal
      def="#TimerIdentifier">TimerIdentifier</nonterminal>
      [<nonterminal def="#ArrayDef">ArrayDef</nonterminal>]
      [<nonterminal def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal def="#TimerValue">TimerValue</nonterminal>]</rhs>
    </production>
    <production id="TimerKeyword">
      <lhs>TimerKeyword</lhs>
      <rhs>"timer"</rhs>
    </production>
    <production id="TimerIdentifier">
      <lhs>TimerIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="TimerValue">
      <lhs>TimerValue</lhs>
      <rhs><nonterminal def="#Expression">Expression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: When
      <nonterminal def="#Expression">Expression</nonterminal> resolves
      to <nonterminal
      def="#SingleExpression">SingleExpression</nonterminal> it must
      resolve to a value of type float. <nonterminal
      def="#Expression">Expression</nonterminal> shall only resolves
      to <nonterminal
      def="#CompoundExpression">CompoundExpression</nonterminal> in
      the initialiation in default timer value assignment for timer
      arrays</lineannotation></rhs>
    </production>
    <production id="TimerRef">
      <lhs>TimerRef</lhs>
      <rhs><nonterminal
      def="#TimerIdentifier">TimerIdentifier</nonterminal>
      [<nonterminal def="#ArrayOrBitRef">ArrayOrBitRef</nonterminal>]
      |<sbr/> <nonterminal
      def="#TimerParIdentifier">TimerParIdentifier</nonterminal>
      [<nonterminal
      def="#ArrayOrBitRef">ArrayOrBitRef</nonterminal>]</rhs>
    </production>
  </productionset>
  <productionset>
    <title>2.3 Component operations</title>
    <production id="ConfigurationStatements">
      <lhs>ConfigurationStatements</lhs>
      <rhs><nonterminal
      def="#ConnectStatement">ConnectStatement</nonterminal> |<sbr/>
      <nonterminal def="#MapStatement">MapStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#DisconnectStatement">DisconnectStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#UnmapStatement">UnmapStatement</nonterminal> |<sbr/>
      <nonterminal def="#DoneStatement">DoneStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#StartTCStatement">StartTCStatement</nonterminal> |<sbr/>
      <nonterminal
      def="#StopTCStatement">StopTCStatement</nonterminal></rhs>
    </production>
    <production id="ConfigurationOps">
      <lhs>ConfigurationOps</lhs>
      <rhs><nonterminal def="#CreateOp">CreateOp</nonterminal> |<sbr/>
      <nonterminal def="#SelfOp">SelfOp</nonterminal> |<sbr/>
      <nonterminal def="#SystemOp">SystemOp</nonterminal> |<sbr/>
      <nonterminal def="#MTCOp">MTCOp</nonterminal> |<sbr/>
      <nonterminal def="#RunningOp">RunningOp</nonterminal></rhs>
    </production>
    <production id="CreateOp">
      <lhs>CreateOp</lhs>
      <rhs><nonterminal
      def="#ComponentType">ComponentType</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#CreateKeyword">CreateKeyword</nonterminal></rhs>
    </production>
    <production id="SystemOp">
      <lhs>SystemOp</lhs>
      <rhs><nonterminal
      def="#SystemKeyword">SystemKeyword</nonterminal></rhs>
    </production>
    <production id="SelfOp">
      <lhs>SelfOp</lhs>
      <rhs>"self"</rhs>
    </production>
    <production id="MTCOp">
      <lhs>MTCOp</lhs>
      <rhs><nonterminal
      def="#MTCKeyword">MTCKeyword</nonterminal></rhs>
    </production>
    <production id="DoneStatement">
      <lhs>DoneStatement</lhs>
      <rhs><nonterminal def="#ComponentId">ComponentId</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#DoneKeyword">DoneKeyword</nonterminal></rhs>
    </production>
    <production id="ComponentId">
      <lhs>ComponentId</lhs>
      <rhs><nonterminal
      def="#ComponentIdentifier">ComponentIdentifier</nonterminal>
      |<sbr/> (<nonterminal def="#AnyKeyword">AnyKeyword</nonterminal>
      |<sbr/> <nonterminal def="#AllKeyword">AllKeyword</nonterminal>)
      <nonterminal
      def="#ComponentKeyword">ComponentKeyword</nonterminal></rhs>
    </production>
    <production id="DoneKeyword">
      <lhs>DoneKeyword</lhs>
      <rhs>"done"</rhs>
    </production>
    <production id="RunningOp">
      <lhs>RunningOp</lhs>
      <rhs><nonterminal def="#ComponentId">ComponentId</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#RunningKeyword">RunningKeyword</nonterminal></rhs>
    </production>
    <production id="RunningKeyword">
      <lhs>RunningKeyword</lhs>
      <rhs>"running"</rhs>
    </production>
    <production id="CreateKeyword">
      <lhs>CreateKeyword</lhs>
      <rhs>"create"</rhs>
    </production>
    <production id="ConnectStatement">
      <lhs>ConnectStatement</lhs>
      <rhs><nonterminal
      def="#ConnectKeyword">ConnectKeyword</nonterminal> <nonterminal
      def="#PortSpec">PortSpec</nonterminal></rhs>
    </production>
    <production id="ConnectKeyword">
      <lhs>ConnectKeyword</lhs>
      <rhs>"connect"</rhs>
    </production>
    <production id="PortSpec">
      <lhs>PortSpec</lhs>
      <rhs>"(" <nonterminal def="#PortRef">PortRef</nonterminal> ","
      <nonterminal def="#PortRef">PortRef</nonterminal> ")"</rhs>
    </production>
    <production id="PortRef">
      <lhs>PortRef</lhs>
      <rhs><nonterminal def="#ComponentRef">ComponentRef</nonterminal>
      <nonterminal def="#Colon">Colon</nonterminal> <nonterminal
      def="#Port">Port</nonterminal></rhs>
    </production>
    <production id="ComponentRef">
      <lhs>ComponentRef</lhs>
      <rhs><nonterminal
      def="#ComponentIdentifier">ComponentIdentifier</nonterminal>
      |<sbr/> <nonterminal def="#SystemOp">SystemOp</nonterminal>
      |<sbr/> <nonterminal def="#SelfOp">SelfOp</nonterminal> |<sbr/>
      <nonterminal def="#MTCOp">MTCOp</nonterminal></rhs>
    </production>
    <production id="DisconnectStatement">
      <lhs>DisconnectStatement</lhs>
      <rhs><nonterminal
      def="#DisconnectKeyword">DisconnectKeyword</nonterminal>
      <nonterminal def="#PortSpec">PortSpec</nonterminal></rhs>
    </production>
    <production id="DisconnectKeyword">
      <lhs>DisconnectKeyword</lhs>
      <rhs>"disconnect"</rhs>
    </production>
    <production id="MapStatement">
      <lhs>MapStatement</lhs>
      <rhs><nonterminal def="#MapKeyword">MapKeyword</nonterminal>
      <nonterminal def="#PortSpec">PortSpec</nonterminal></rhs>
    </production>
    <production id="MapKeyword">
      <lhs>MapKeyword</lhs>
      <rhs>"map"</rhs>
    </production>
    <production id="UnmapStatement">
      <lhs>UnmapStatement</lhs>
      <rhs><nonterminal def="#UnmapKeyword">UnmapKeyword</nonterminal>
      <nonterminal def="#PortSpec">PortSpec</nonterminal></rhs>
    </production>
    <production id="UnmapKeyword">
      <lhs>UnmapKeyword</lhs>
      <rhs>"unmap"</rhs>
    </production>
    <production id="StartTCStatement">
      <lhs>StartTCStatement</lhs>
      <rhs><nonterminal
      def="#ComponentIdentifier">ComponentIdentifier</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#StartKeyword">StartKeyword</nonterminal> "(" <nonterminal
      def="#FunctionInstance">FunctionInstance</nonterminal> ")"
      <lineannotation><emphasis>Static semantics</emphasis>: the
      Function instance may only have in parameters</lineannotation>
      <lineannotation><emphasis>Static semantics</emphasis>: the
      Function instance shall not
      have timer parameters</lineannotation></rhs>
    </production>
    <production id="StartKeyword">
      <lhs>StartKeyword</lhs>
      <rhs>"start"</rhs>
    </production>
    <production id="StopTCStatement">
      <lhs>StopTCStatement</lhs>
      <rhs><nonterminal def="#StopKeyword">StopKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#ComponentIdentifier">ComponentIdentifier</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#StopKeyword">StopKeyword</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      <nonterminal
      def="#ComponentKeyword">ComponentKeyword</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#StopKeyword">StopKeyword</nonterminal></rhs>
    </production>
    <production id="ComponentIdentifier">
      <lhs>ComponentIdentifier</lhs>
      <rhs><nonterminal def="#VariableRef">VariableRef</nonterminal>
      |<sbr/> <nonterminal
      def="#FunctionInstance">FunctionInstance</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: the
      variable associated with <nonterminal
      def="#VariableRef">VariableRef</nonterminal> or the Return type
      associated with <nonterminal
      def="#FunctionInstance">FunctionInstance</nonterminal> must be
      of component type</lineannotation></rhs>
    </production>
  </productionset>
  <productionset>
    <title>2.4 Port operations</title>
    <production id="Port">
      <lhs>Port</lhs>
      <rhs>(<nonterminal
      def="#PortIdentifier">PortIdentifier</nonterminal> |<sbr/>
      <nonterminal
       def="#PortParIdentifier">PortParIdentifier</nonterminal>)
       [<nonterminal
      def="#ArrayOrBitRef">ArrayOrBitRef</nonterminal>]</rhs>
    </production>
    <production id="CommunicationStatements">
      <lhs>CommunicationStatements</lhs>
      <rhs><nonterminal
      def="#SendStatement">SendStatement</nonterminal> |<sbr/>
      <nonterminal def="#CallStatement">CallStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#ReplyStatement">ReplyStatement</nonterminal> |<sbr/>
      <nonterminal def="#RaiseStatement">RaiseStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#ReceiveStatement">ReceiveStatement</nonterminal> |<sbr/>
      <nonterminal
       def="#TriggerStatement">TriggerStatement</nonterminal> |<sbr/>
       <nonterminal
	def="#GetCallStatement">GetCallStatement</nonterminal> |<sbr/>
	<nonterminal
	 def="#GetReplyStatement">GetReplyStatement</nonterminal> |<sbr/>
	 <nonterminal def="#CatchStatement">CatchStatement</nonterminal>
	 |<sbr/> <nonterminal
	 def="#CheckStatement">CheckStatement</nonterminal> |<sbr/>
	 <nonterminal def="#ClearStatement">ClearStatement</nonterminal>
	 |<sbr/> <nonterminal
	 def="#StartStatement">StartStatement</nonterminal> |<sbr/>
	 <nonterminal
      def="#StopStatement">StopStatement</nonterminal></rhs>
    </production>
    <production id="SendStatement">
      <lhs>SendStatement</lhs>
      <rhs><nonterminal def="#Port">Port</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortSendOp">PortSendOp</nonterminal></rhs>
    </production>
    <production id="PortSendOp">
      <lhs>PortSendOp</lhs>
      <rhs><nonterminal
      def="#SendOpKeyword">SendOpKeyword</nonterminal> "("
      <nonterminal def="#SendParameter">SendParameter</nonterminal>
      ")" [<nonterminal def="#ToClause">ToClause</nonterminal>]</rhs>
    </production>
    <production id="SendOpKeyword">
      <lhs>SendOpKeyword</lhs>
      <rhs>"send"</rhs>
    </production>
    <production id="SendParameter">
      <lhs>SendParameter</lhs>
      <rhs><nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal></rhs>
    </production>
    <production id="ToClause">
      <lhs>ToClause</lhs>
      <rhs><nonterminal def="#ToKeyword">ToKeyword</nonterminal>
      <nonterminal def="#AddressRef">AddressRef</nonterminal></rhs>
    </production>
    <production id="ToKeyword">
      <lhs>ToKeyword</lhs>
      <rhs>"to"</rhs>
    </production>
    <production id="AddressRef">
      <lhs>AddressRef</lhs>
      <rhs><nonterminal def="#VariableRef">VariableRef</nonterminal>
      |<sbr/> <nonterminal
      def="#FunctionInstance">FunctionInstance</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#VariableRef">VariableRef</nonterminal> and
      <nonterminal
      def="#FunctionInstance">FunctionInstance</nonterminal> return
      must be of address or component type</lineannotation></rhs>
    </production>
    <production id="CallStatement">
      <lhs>CallStatement</lhs>
      <rhs><nonterminal def="#Port">Port</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortCallOp">PortCallOp</nonterminal> [<nonterminal
      def="#PortCallBody">PortCallBody</nonterminal>]</rhs>
    </production>
    <production id="PortCallOp">
      <lhs>PortCallOp</lhs>
      <rhs><nonterminal
      def="#CallOpKeyword">CallOpKeyword</nonterminal> "("
      <nonterminal def="#CallParameters">CallParameters</nonterminal>
      ")" [<nonterminal def="#ToClause">ToClause</nonterminal>]</rhs>
    </production>
    <production id="CallOpKeyword">
      <lhs>CallOpKeyword</lhs>
      <rhs>"call"</rhs>
    </production>
    <production id="CallParameters">
      <lhs>CallParameters</lhs>
      <rhs><nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal> [","
      <nonterminal def="#CallTimerValue">CallTimerValue</nonterminal>]
      <lineannotation><emphasis>Static semantics</emphasis>: only out
      parameters may be omitted or specified with a matching
      attribute</lineannotation></rhs>
    </production>
    <production id="CallTimerValue">
      <lhs>CallTimerValue</lhs>
      <rhs><nonterminal def="#TimerValue">TimerValue</nonterminal>
      |<sbr/> <nonterminal
      def="#NowaitKeyword">NowaitKeyword</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: Value must
      be of type float</lineannotation></rhs>
    </production>
    <production id="NowaitKeyword">
      <lhs>NowaitKeyword</lhs>
      <rhs>"nowait"</rhs>
    </production>
    <production id="PortCallBody">
      <lhs>PortCallBody</lhs>
      <rhs><nonterminal def="#BeginChar">BeginChar</nonterminal>
      <nonterminal
      def="#CallBodyStatementList">CallBodyStatementList</nonterminal>
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="CallBodyStatementList">
      <lhs>CallBodyStatementList</lhs>
      <rhs>{<nonterminal
      def="#CallBodyStatement">CallBodyStatement</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+</rhs>
    </production>
    <production id="CallBodyStatement">
      <lhs>CallBodyStatement</lhs>
      <rhs><nonterminal
      def="#CallBodyGuard">CallBodyGuard</nonterminal> <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
    <production id="CallBodyGuard">
      <lhs>CallBodyGuard</lhs>
      <rhs><nonterminal def="#AltGuardChar">AltGuardChar</nonterminal>
      <nonterminal def="#CallBodyOps">CallBodyOps</nonterminal></rhs>
    </production>
    <production id="CallBodyOps">
      <lhs>CallBodyOps</lhs>
      <rhs><nonterminal
      def="#GetReplyStatement">GetReplyStatement</nonterminal> |<sbr/>
      <nonterminal
      def="#CatchStatement">CatchStatement</nonterminal></rhs>
    </production>
    <production id="ReplyStatement">
      <lhs>ReplyStatement</lhs>
      <rhs><nonterminal def="#Port">Port</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortReplyOp">PortReplyOp</nonterminal></rhs>
    </production>
    <production id="PortReplyOp">
      <lhs>PortReplyOp</lhs>
      <rhs><nonterminal def="#ReplyKeyword">ReplyKeyword</nonterminal>
      "(" <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal>
      [<nonterminal def="#ReplyValue">ReplyValue</nonterminal>]")"
      [<nonterminal def="#ToClause">ToClause</nonterminal>]</rhs>
    </production>
    <production id="ReplyKeyword">
      <lhs>ReplyKeyword</lhs>
      <rhs>"reply"</rhs>
    </production>
    <production id="ReplyValue">
      <lhs>ReplyValue</lhs>
      <rhs><nonterminal def="#ValueKeyword">ValueKeyword</nonterminal>
      <nonterminal def="#Expression">Expression</nonterminal></rhs>
    </production>
    <production id="RaiseStatement">
      <lhs>RaiseStatement</lhs>
      <rhs><nonterminal def="#Port">Port</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortRaiseOp">PortRaiseOp</nonterminal></rhs>
    </production>
    <production id="PortRaiseOp">
      <lhs>PortRaiseOp</lhs>
      <rhs><nonterminal def="#RaiseKeyword">RaiseKeyword</nonterminal>
      "(" <nonterminal def="#Signature">Signature</nonterminal> ","
      <nonterminal
       def="#TemplateInstance">TemplateInstance</nonterminal> ")"
      [<nonterminal def="#ToClause">ToClause</nonterminal>]</rhs>
    </production>
    <production id="RaiseKeyword">
      <lhs>RaiseKeyword</lhs>
      <rhs>"raise"</rhs>
    </production>
    <production id="ReceiveStatement">
      <lhs>ReceiveStatement</lhs>
      <rhs><nonterminal def="#PortOrAny">PortOrAny</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortReceiveOp">PortReceiveOp</nonterminal></rhs>
    </production>
    <production id="PortOrAny">
      <lhs>PortOrAny</lhs>
      <rhs><nonterminal def="#Port">Port</nonterminal> |<sbr/>
      <nonterminal def="#AnyKeyword">AnyKeyword</nonterminal>
      <nonterminal def="#PortKeyword">PortKeyword</nonterminal></rhs>
    </production>
    <production id="PortReceiveOp">
      <lhs>PortReceiveOp</lhs>
      <rhs><nonterminal
      def="#ReceiveOpKeyword">ReceiveOpKeyword</nonterminal> ["("
      <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal> ")"]
      [<nonterminal def="#FromClause">FromClause</nonterminal>]
      [<nonterminal def="#PortRedirect">PortRedirect</nonterminal>]
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal def="#PortRedirect">PortRedirect</nonterminal>
      option may only be present if the <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal> option is
      also present</lineannotation></rhs>
    </production>
    <production id="ReceiveOpKeyword">
      <lhs>ReceiveOpKeyword</lhs>
      <rhs>"receive"</rhs>
    </production>
    <production id="ReceiveParameter">
      <lhs>ReceiveParameter</lhs>
      <rhs><nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal></rhs>
    </production>
    <production id="FromClause">
      <lhs>FromClause</lhs>
      <rhs><nonterminal def="#FromKeyword">FromKeyword</nonterminal>
      <nonterminal def="#AddressRef">AddressRef</nonterminal></rhs>
    </production>
    <production id="FromKeyword">
      <lhs>FromKeyword</lhs>
      <rhs>"from"</rhs>
    </production>
    <production id="PortRedirect">
      <lhs>PortRedirect</lhs>
      <rhs><nonterminal
      def="#PortRedirectSymbol">PortRedirectSymbol</nonterminal>
      (<nonterminal def="#ValueSpec">ValueSpec</nonterminal>
      [<nonterminal def="#SenderSpec">SenderSpec</nonterminal>]
      |<sbr/> <nonterminal
      def="#SenderSpec">SenderSpec</nonterminal>)</rhs>
    </production>
    <production id="PortRedirectSymbol">
      <lhs>PortRedirectSymbol</lhs>
      <rhs>"->"</rhs>
    </production>
    <production id="ValueSpec">
      <lhs>ValueSpec</lhs>
      <rhs><nonterminal def="#ValueKeyword">ValueKeyword</nonterminal>
      <nonterminal def="#VariableRef">VariableRef</nonterminal></rhs>
    </production>
    <production id="ValueKeyword">
      <lhs>ValueKeyword</lhs>
      <rhs>"value"</rhs>
    </production>
    <production id="SenderSpec">
      <lhs>SenderSpec</lhs>
      <rhs><nonterminal
      def="#SenderKeyword">SenderKeyword</nonterminal> <nonterminal
      def="#VariableRef">VariableRef</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: <nonterminal
      def="#VariableRef">VariableRef</nonterminal> must be of address
      or component type</lineannotation></rhs>
    </production>
    <production id="SenderKeyword">
      <lhs>SenderKeyword</lhs>
      <rhs>"sender"</rhs>
    </production>
    <production id="TriggerStatement">
      <lhs>TriggerStatement</lhs>
      <rhs><nonterminal def="#PortOrAny">PortOrAny</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortTriggerOp">PortTriggerOp</nonterminal></rhs>
    </production>
    <production id="PortTriggerOp">
      <lhs>PortTriggerOp</lhs>
      <rhs><nonterminal
      def="#TriggerOpKeyword">TriggerOpKeyword</nonterminal> ["("
      <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal> ")"]
      [<nonterminal def="#FromClause">FromClause</nonterminal>]
      [<nonterminal def="#PortRedirect">PortRedirect</nonterminal>]
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal def="#PortRedirect">PortRedirect</nonterminal>
      option may only be present if the <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal> option is
      also present</lineannotation></rhs>
    </production>
    <production id="TriggerOpKeyword">
      <lhs>TriggerOpKeyword</lhs>
      <rhs>"trigger"</rhs>
    </production>
    <production id="GetCallStatement">
      <lhs>GetCallStatement</lhs>
      <rhs><nonterminal def="#PortOrAny">PortOrAny</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortGetCallOp">PortGetCallOp</nonterminal></rhs>
    </production>
    <production id="PortGetCallOp">
      <lhs>PortGetCallOp</lhs>
      <rhs><nonterminal
      def="#GetCallOpKeyword">GetCallOpKeyword</nonterminal> ["("
      <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal> ")"]
      [<nonterminal def="#FromClause">FromClause</nonterminal>]
      [<nonterminal
      def="#PortRedirectWithParam">PortRedirectWithParam</nonterminal>]
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal
      def="#PortRedirectWithParam">PortRedirectWithParam</nonterminal>
      option may only be present if the <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal> option is
      also present</lineannotation></rhs>
    </production>
    <production id="GetCallOpKeyword">
      <lhs>GetCallOpKeyword</lhs>
      <rhs>"getcall"</rhs>
    </production>
    <production id="PortRedirectWithParam">
      <lhs>PortRedirectWithParam</lhs>
      <rhs><nonterminal
      def="#PortRedirectSymbol">PortRedirectSymbol</nonterminal>
      <nonterminal
      def="#RedirectSpec">RedirectSpec</nonterminal></rhs>
    </production>
    <production id="RedirectSpec">
      <lhs>RedirectSpec</lhs>
      <rhs><nonterminal def="#ValueSpec">ValueSpec</nonterminal>
      [<nonterminal def="#ParaSpec">ParaSpec</nonterminal>]
      [<nonterminal def="#SenderSpec">SenderSpec</nonterminal>]
      |<sbr/> <nonterminal def="#ParaSpec">ParaSpec</nonterminal>
      [<nonterminal def="#SenderSpec">SenderSpec</nonterminal>]
      |<sbr/> <nonterminal
      def="#SenderSpec">SenderSpec</nonterminal></rhs>
    </production>
    <production id="ParaSpec">
      <lhs>ParaSpec</lhs>
      <rhs><nonterminal def="#ParaKeyword">ParaKeyword</nonterminal>
      <nonterminal
      def="#ParaAssignmentList">ParaAssignmentList</nonterminal></rhs>
    </production>
    <production id="ParaKeyword">
      <lhs>ParaKeyword</lhs>
      <rhs>"param"</rhs>
    </production>
    <production id="ParaAssignmentList">
      <lhs>ParaAssignmentList</lhs>
      <rhs>"(" (<nonterminal
      def="#AssignmentList">AssignmentList</nonterminal> |<sbr/>
      <nonterminal def="#VariableList">VariableList</nonterminal>)
      ")"</rhs>
    </production>
    <production id="AssignmentList">
      <lhs>AssignmentList</lhs>
      <rhs><nonterminal
      def="#VariableAssignment">VariableAssignment</nonterminal> {","
      <nonterminal
      def="#VariableAssignment">VariableAssignment</nonterminal>}</rhs>
    </production>
    <production id="VariableAssignment">
      <lhs>VariableAssignment</lhs>
      <rhs><nonterminal def="#VariableRef">VariableRef</nonterminal>
      <nonterminal def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal
      def="#ParameterIdentifier">ParameterIdentifier</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal
      def="#ParameterIdentifier">ParameterIdentifiers</nonterminal>
      must be from the corresponding signature
      definition</lineannotation></rhs>
    </production>
    <production id="ParameterIdentifier">
      <lhs>ParameterIdentifier</lhs>
      <rhs><nonterminal
      def="#ValueParIdentifier">ValueParIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#TimerParIdentifier">TimerParIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#TemplateParIdentifier">TemplateParIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#PortParIdentifier">PortParIdentifier</nonterminal></rhs>
    </production>
    <production id="VariableList">
      <lhs>VariableList</lhs>
      <rhs><nonterminal
      def="#VariableEntry">VariableEntry</nonterminal> {","
      <nonterminal
      def="#VariableEntry">VariableEntry</nonterminal>}</rhs>
    </production>
    <production id="VariableEntry">
      <lhs>VariableEntry</lhs>
      <rhs><nonterminal def="#VariableRef">VariableRef</nonterminal>
      |<sbr/> <nonterminal
      def="#NotUsedSymbol">NotUsedSymbol</nonterminal></rhs>
    </production>
    <production id="GetReplyStatement">
      <lhs>GetReplyStatement</lhs>
      <rhs><nonterminal def="#PortOrAny">PortOrAny</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortGetReplyOp">PortGetReplyOp</nonterminal></rhs>
    </production>
    <production id="PortGetReplyOp">
      <lhs>PortGetReplyOp</lhs>
      <rhs><nonterminal
      def="#GetReplyOpKeyword">GetReplyOpKeyword</nonterminal> ["("
      <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal>
      [<nonterminal
      def="#ValueMatchSpec">ValueMatchSpec</nonterminal>] ")"]
      [<nonterminal def="#FromClause">FromClause</nonterminal>]
      [<nonterminal
      def="#PortRedirectWithParam">PortRedirectWithParam</nonterminal>]
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal
      def="#PortRedirectWithParam">PortRedirectWithParam</nonterminal>
      option may only be present if the <nonterminal
      def="#ReceiveParameter">ReceiveParameter</nonterminal> option is
      also present</lineannotation></rhs>
    </production>
    <production id="GetReplyOpKeyword">
      <lhs>GetReplyOpKeyword</lhs>
      <rhs>"getreply"</rhs>
    </production>
    <production id="ValueMatchSpec">
      <lhs>ValueMatchSpec</lhs>
      <rhs><nonterminal def="#ValueKeyword">ValueKeyword</nonterminal>
      <nonterminal
      def="#TemplateInstance">TemplateInstance</nonterminal></rhs>
    </production>
    <production id="CheckStatement">
      <lhs>CheckStatement</lhs>
      <rhs><nonterminal def="#PortOrAny">PortOrAny</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortCheckOp">PortCheckOp</nonterminal></rhs>
    </production>
    <production id="PortCheckOp">
      <lhs>PortCheckOp</lhs>
      <rhs><nonterminal
      def="#CheckOpKeyword">CheckOpKeyword</nonterminal> ["("
      <nonterminal def="#CheckParameter">CheckParameter</nonterminal>
      ")"]</rhs>
    </production>
    <production id="CheckOpKeyword">
      <lhs>CheckOpKeyword</lhs>
      <rhs>"check"</rhs>
    </production>
    <production id="CheckParameter">
      <lhs>CheckParameter</lhs>
      <rhs><nonterminal
      def="#CheckPortOpsPresent">CheckPortOpsPresent</nonterminal>
      |<sbr/> <nonterminal
      def="#FromClausePresent">FromClausePresent</nonterminal> |<sbr/>
      <nonterminal
      def="#RedirectPresent">RedirectPresent</nonterminal></rhs>
    </production>
    <production id="FromClausePresent">
      <lhs>FromClausePresent</lhs>
      <rhs><nonterminal def="#FromClause">FromClause</nonterminal>
      [<nonterminal
      def="#PortRedirectSymbol">PortRedirectSymbol</nonterminal>
      <nonterminal def="#SenderSpec">SenderSpec</nonterminal>]</rhs>
    </production>
    <production id="RedirectPresent">
      <lhs>RedirectPresent</lhs>
      <rhs><nonterminal
      def="#PortRedirectSymbol">PortRedirectSymbol</nonterminal>
      <nonterminal def="#SenderSpec">SenderSpec</nonterminal></rhs>
    </production>
    <production id="CheckPortOpsPresent">
      <lhs>CheckPortOpsPresent</lhs>
      <rhs><nonterminal
      def="#PortReceiveOp">PortReceiveOp</nonterminal> |<sbr/>
      <nonterminal def="#PortGetCallOp">PortGetCallOp</nonterminal>
      |<sbr/> <nonterminal
      def="#PortGetReplyOp">PortGetReplyOp</nonterminal> |<sbr/>
      <nonterminal def="#PortCatchOp">PortCatchOp</nonterminal></rhs>
    </production>
    <production id="CatchStatement">
      <lhs>CatchStatement</lhs>
      <rhs><nonterminal def="#PortOrAny">PortOrAny</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortCatchOp">PortCatchOp</nonterminal></rhs>
    </production>
    <production id="PortCatchOp">
      <lhs>PortCatchOp</lhs>
      <rhs><nonterminal
      def="#CatchOpKeyword">CatchOpKeyword</nonterminal>
      ["("<nonterminal
      def="#CatchOpParameter">CatchOpParameter</nonterminal> ")"]
      [<nonterminal def="#FromClause">FromClause</nonterminal>]
      [<nonterminal def="#PortRedirect">PortRedirect</nonterminal>]
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal def="#PortRedirect">PortRedirect</nonterminal>
      option may only be present if the <nonterminal
      def="#CatchOpParameter">CatchOpParameter</nonterminal> option is
      also present</lineannotation></rhs>
    </production>
    <production id="CatchOpKeyword">
      <lhs>CatchOpKeyword</lhs>
      <rhs>"catch"</rhs>
    </production>
    <production id="CatchOpParameter">
      <lhs>CatchOpParameter</lhs>
      <rhs><nonterminal def="#Signature">Signature</nonterminal> ","
      <nonterminal
       def="#TemplateInstance">TemplateInstance</nonterminal> |<sbr/>
       <nonterminal
      def="#TimeoutKeyword">TimeoutKeyword</nonterminal></rhs>
    </production>
    <production id="ClearStatement">
      <lhs>ClearStatement</lhs>
      <rhs><nonterminal def="#PortOrAll">PortOrAll</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortClearOp">PortClearOp</nonterminal></rhs>
    </production>
    <production id="PortOrAll">
      <lhs>PortOrAll</lhs>
      <rhs><nonterminal def="#Port">Port</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      <nonterminal def="#PortKeyword">PortKeyword</nonterminal></rhs>
    </production>
    <production id="PortClearOp">
      <lhs>PortClearOp</lhs>
      <rhs><nonterminal
      def="#ClearOpKeyword">ClearOpKeyword</nonterminal></rhs>
    </production>
    <production id="ClearOpKeyword">
      <lhs>ClearOpKeyword</lhs>
      <rhs>"clear"</rhs>
    </production>
    <production id="StartStatement">
      <lhs>StartStatement</lhs>
      <rhs><nonterminal def="#PortOrAll">PortOrAll</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortStartOp">PortStartOp</nonterminal></rhs>
    </production>
    <production id="PortStartOp">
      <lhs>PortStartOp</lhs>
      <rhs><nonterminal
      def="#StartKeyword">StartKeyword</nonterminal></rhs>
    </production>
    <production id="StopStatement">
      <lhs>StopStatement</lhs>
      <rhs><nonterminal def="#PortOrAll">PortOrAll</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#PortStopOp">PortStopOp</nonterminal></rhs>
    </production>
    <production id="PortStopOp">
      <lhs>PortStopOp</lhs>
      <rhs><nonterminal
      def="#StopKeyword">StopKeyword</nonterminal></rhs>
    </production>
    <production id="StopKeyword">
      <lhs>StopKeyword</lhs>
      <rhs>"stop"</rhs>
    </production>
    <production id="AnyKeyword">
      <lhs>AnyKeyword</lhs>
      <rhs>"any"</rhs>
    </production>
  </productionset>
  <productionset>
    <title>2.5 Timer operations</title>
    <production id="TimerStatements">
      <lhs>TimerStatements</lhs>
      <rhs><nonterminal
      def="#StartTimerStatement">StartTimerStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#StopTimerStatement">StopTimerStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#TimeoutStatement">TimeoutStatement</nonterminal></rhs>
    </production>
    <production id="TimerOps">
      <lhs>TimerOps</lhs>
      <rhs><nonterminal def="#ReadTimerOp">ReadTimerOp</nonterminal>
      |<sbr/> <nonterminal
      def="#RunningTimerOp">RunningTimerOp</nonterminal></rhs>
    </production>
    <production id="StartTimerStatement">
      <lhs>StartTimerStatement</lhs>
      <rhs><nonterminal def="#TimerRef">TimerRef</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#StartKeyword">StartKeyword</nonterminal> ["(" <nonterminal
      def="#TimerValue">TimerValue</nonterminal> ")"]</rhs>
    </production>
    <production id="StopTimerStatement">
      <lhs>StopTimerStatement</lhs>
      <rhs><nonterminal
      def="#TimerRefOrAll">TimerRefOrAll</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#StopKeyword">StopKeyword</nonterminal></rhs>
    </production>
    <production id="TimerRefOrAll">
      <lhs>TimerRefOrAll</lhs>
      <rhs><nonterminal def="#TimerRef">TimerRef</nonterminal> |<sbr/>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      <nonterminal
      def="#TimerKeyword">TimerKeyword</nonterminal></rhs>
    </production>
    <production id="ReadTimerOp">
      <lhs>ReadTimerOp</lhs>
      <rhs><nonterminal def="#TimerRef">TimerRef</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#ReadKeyword">ReadKeyword</nonterminal></rhs>
    </production>
    <production id="ReadKeyword">
      <lhs>ReadKeyword</lhs>
      <rhs>"read"</rhs>
    </production>
    <production id="RunningTimerOp">
      <lhs>RunningTimerOp</lhs>
      <rhs><nonterminal
      def="#TimerRefOrAny">TimerRefOrAny</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#RunningKeyword">RunningKeyword</nonterminal></rhs>
    </production>
    <production id="TimeoutStatement">
      <lhs>TimeoutStatement</lhs>
      <rhs><nonterminal
      def="#TimerRefOrAny">TimerRefOrAny</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal> <nonterminal
      def="#TimeoutKeyword">TimeoutKeyword</nonterminal></rhs>
    </production>
    <production id="TimerRefOrAny">
      <lhs>TimerRefOrAny</lhs>
      <rhs><nonterminal def="#TimerRef">TimerRef</nonterminal> |<sbr/>
      <nonterminal def="#AnyKeyword">AnyKeyword</nonterminal>
      <nonterminal
      def="#TimerKeyword">TimerKeyword</nonterminal></rhs>
    </production>
    <production id="TimeoutKeyword">
      <lhs>TimeoutKeyword</lhs>
      <rhs>"timeout"</rhs>
    </production>
  </productionset>
  <productionset>
    <title>3 Type</title>
    <production id="Type">
      <lhs>Type</lhs>
      <rhs><nonterminal
      def="#PredefinedType">PredefinedType</nonterminal> |<sbr/>
      <nonterminal
      def="#ReferencedType">ReferencedType</nonterminal></rhs>
    </production>
    <production id="PredefinedType">
      <lhs>PredefinedType</lhs>
      <rhs><nonterminal
      def="#BitStringKeyword">BitStringKeyword</nonterminal> |<sbr/>
      <nonterminal def="#BooleanKeyword">BooleanKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#CharStringKeyword">CharStringKeyword</nonterminal> |<sbr/>
      <nonterminal
      def="#UniversalCharString">UniversalCharString</nonterminal>
      |<sbr/> <nonterminal
      def="#CharKeyword">CharKeyword</nonterminal> |<sbr/>
      <nonterminal def="#UniversalChar">UniversalChar</nonterminal>
      |<sbr/> <nonterminal
      def="#IntegerKeyword">IntegerKeyword</nonterminal> |<sbr/>
      <nonterminal
      def="#OctetStringKeyword">OctetStringKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#ObjectIdentifierKeyword">ObjectIdentifierKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#HexStringKeyword">HexStringKeyword</nonterminal> |<sbr/>
      <nonterminal
      def="#VerdictTypeKeyword">VerdictTypeKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#FloatKeyword">FloatKeyword</nonterminal> |<sbr/>
      <nonterminal def="#AddressKeyword">AddressKeyword</nonterminal>
      |<sbr/> <nonterminal
      def="#DefaultKeyword">DefaultKeyword</nonterminal> |<sbr/>
      <nonterminal
      def="#AnyTypeKeyword">AnyTypeKeyword</nonterminal></rhs>
    </production>
    <production id="BitStringKeyword">
      <lhs>BitStringKeyword</lhs>
      <rhs>"bitstring"</rhs>
    </production>
    <production id="BooleanKeyword">
      <lhs>BooleanKeyword</lhs>
      <rhs>"boolean"</rhs>
    </production>
    <production id="IntegerKeyword">
      <lhs>IntegerKeyword</lhs>
      <rhs>"integer"</rhs>
    </production>
    <production id="OctetStringKeyword">
      <lhs>OctetStringKeyword</lhs>
      <rhs>"octetstring"</rhs>
    </production>
    <production id="ObjectIdentifierKeyword">
      <lhs>ObjectIdentifierKeyword</lhs>
      <rhs>"objid"</rhs>
    </production>
    <production id="HexStringKeyword">
      <lhs>HexStringKeyword</lhs>
      <rhs>"hexstring"</rhs>
    </production>
    <production id="VerdictTypeKeyword">
      <lhs>VerdictTypeKeyword</lhs>
      <rhs>"verdicttype"</rhs>
    </production>
    <production id="FloatKeyword">
      <lhs>FloatKeyword</lhs>
      <rhs>"float"</rhs>
    </production>
    <production id="AddressKeyword">
      <lhs>AddressKeyword</lhs>
      <rhs>"address"</rhs>
    </production>
    <production id="DefaultKeyword">
      <lhs>DefaultKeyword</lhs>
      <rhs>"default"</rhs>
    </production>
    <production id="AnyTypeKeyword">
      <lhs>AnyTypeKeyword</lhs>
      <rhs>"anytype"</rhs>
    </production>
    <production id="CharStringKeyword">
      <lhs>CharStringKeyword</lhs>
      <rhs>"charstring"</rhs>
    </production>
    <production id="UniversalCharString">
      <lhs>UniversalCharString</lhs>
      <rhs><nonterminal
      def="#UniversalKeyword">UniversalKeyword</nonterminal>
      <nonterminal
      def="#CharStringKeyword">CharStringKeyword</nonterminal></rhs>
    </production>
    <production id="UniversalKeyword">
      <lhs>UniversalKeyword</lhs>
      <rhs>"universal"</rhs>
    </production>
    <production id="CharKeyword">
      <lhs>CharKeyword</lhs>
      <rhs>"char"</rhs>
    </production>
    <production id="UniversalChar">
      <lhs>UniversalChar</lhs>
      <rhs><nonterminal
      def="#UniversalKeyword">UniversalKeyword</nonterminal>
      <nonterminal def="#CharKeyword">CharKeyword</nonterminal></rhs>
    </production>
    <production id="ReferencedType">
      <lhs>ReferencedType</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> <nonterminal
      def="#Dot">Dot</nonterminal>] <nonterminal
      def="#TypeReference">TypeReference</nonterminal> [<nonterminal
      def="#ExtendedFieldReference">ExtendedFieldReference</nonterminal>]</rhs>
    </production>
    <production id="TypeReference">
      <lhs>TypeReference</lhs>
      <rhs><nonterminal
      def="#StructTypeIdentifier">StructTypeIdentifier</nonterminal>[<nonterminal
      def="#TypeActualParList">TypeActualParList</nonterminal>]
      |<sbr/> <nonterminal
      def="#EnumTypeIdentifier">EnumTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#SubTypeIdentifier">SubTypeIdentifier</nonterminal> |<sbr/>
      <nonterminal
      def="#ComponentTypeIdentifier">ComponentTypeIdentifier</nonterminal></rhs>
    </production>
    <production id="TypeActualParList">
      <lhs>TypeActualParList</lhs>
      <rhs>"(" <nonterminal
      def="#TypeActualPar">TypeActualPar</nonterminal> {","
      <nonterminal def="#TypeActualPar">TypeActualPar</nonterminal>}
      ")"</rhs>
    </production>
    <production id="TypeActualPar">
      <lhs>TypeActualPar</lhs>
      <rhs><nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal></rhs>
    </production>
    <production id="ArrayDef">
      <lhs>ArrayDef</lhs>
      <rhs>{"[" <nonterminal
      def="#ArrayBounds">ArrayBounds</nonterminal> [".." <nonterminal
      def="#ArrayBounds">ArrayBounds</nonterminal>] "]"}+</rhs>
    </production>
    <production id="ArrayBounds">
      <lhs>ArrayBounds</lhs>
      <rhs><nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#ArrayBounds">ArrayBounds</nonterminal> will
      resolve to a non negative value of integer
      type</lineannotation></rhs>
    </production>
  </productionset>
  <productionset>
    <title>4 Value</title>
    <production id="Value">
      <lhs>Value</lhs>
      <rhs><nonterminal
      def="#PredefinedValue">PredefinedValue</nonterminal> |<sbr/>
      <nonterminal
      def="#ReferencedValue">ReferencedValue</nonterminal></rhs>
    </production>
    <production id="PredefinedValue">
      <lhs>PredefinedValue</lhs>
      <rhs><nonterminal
      def="#BitStringValue">BitStringValue</nonterminal> |<sbr/>
      <nonterminal def="#BooleanValue">BooleanValue</nonterminal>
      |<sbr/> <nonterminal
      def="#CharStringValue">CharStringValue</nonterminal> |<sbr/>
      <nonterminal def="#IntegerValue">IntegerValue</nonterminal>
      |<sbr/> <nonterminal
      def="#OctetStringValue">OctetStringValue</nonterminal> |<sbr/>
      <nonterminal
      def="#ObjectIdentifierValue">ObjectIdentifierValue</nonterminal>
      |<sbr/> <nonterminal
      def="#HexStringValue">HexStringValue</nonterminal> |<sbr/>
      <nonterminal
       def="#VerdictTypeValue">VerdictTypeValue</nonterminal> |<sbr/>
       <nonterminal
	def="#EnumeratedValue">EnumeratedValue</nonterminal> |<sbr/>
	<nonterminal def="#FloatValue">FloatValue</nonterminal> |<sbr/>
	<nonterminal def="#AddressValue">AddressValue</nonterminal>
	|<sbr/> <nonterminal
      def="#OmitValue">OmitValue</nonterminal></rhs>
    </production>
    <production id="BitStringValue">
      <lhs>BitStringValue</lhs>
      <rhs><nonterminal def="#Bstring">Bstring</nonterminal></rhs>
    </production>
    <production id="BooleanValue">
      <lhs>BooleanValue</lhs>
      <rhs>"true" |<sbr/> "false"</rhs>
    </production>
    <production id="IntegerValue">
      <lhs>IntegerValue</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal></rhs>
    </production>
    <production id="OctetStringValue">
      <lhs>OctetStringValue</lhs>
      <rhs><nonterminal def="#Ostring">Ostring</nonterminal></rhs>
    </production>
    <production id="ObjectIdentifierValue">
      <lhs>ObjectIdentifierValue</lhs>
      <rhs><nonterminal
      def="#ObjectIdentifierKeyword">ObjectIdentifierKeyword</nonterminal>
      "{" <nonterminal
      def="#ObjIdComponentList">ObjIdComponentList</nonterminal> "}"
      <lineannotation>ReferencedValue must be of type object
      identifier</lineannotation></rhs>
    </production>
    <production id="ObjIdComponentList">
      <lhs>ObjIdComponentList</lhs>
      <rhs>{<nonterminal
      def="#ObjIdComponent">ObjIdComponent</nonterminal>}+</rhs>
    </production>
    <production id="ObjIdComponent">
      <lhs>ObjIdComponent</lhs>
      <rhs><nonterminal def="#NameForm">NameForm</nonterminal> |<sbr/>
      <nonterminal def="#NumberForm">NumberForm</nonterminal> |<sbr/>
      <nonterminal
      def="#NameAndNumberForm">NameAndNumberForm</nonterminal></rhs>
    </production>
    <production id="NumberForm">
      <lhs>NumberForm</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal> |<sbr/>
      <nonterminal
      def="#ReferencedValue">ReferencedValue</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal
      def="#ReferencedValue">ReferencedValue</nonterminal> must be of
      type integer and have a non negative
      Value</lineannotation></rhs>
    </production>
    <production id="NameAndNumberForm">
      <lhs>NameAndNumberForm</lhs>
      <rhs><nonterminal def="#Identifier">Identifier</nonterminal> "("
      <nonterminal def="#NumberForm">NumberForm</nonterminal>
      ")"</rhs>
    </production>
    <production id="NameForm">
      <lhs>NameForm</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="HexStringValue">
      <lhs>HexStringValue</lhs>
      <rhs><nonterminal def="#Hstring">Hstring</nonterminal></rhs>
    </production>
    <production id="VerdictTypeValue">
      <lhs>VerdictTypeValue</lhs>
      <rhs>"pass" |<sbr/> "fail" |<sbr/> "inconc" |<sbr/> "none"
      |<sbr/> "error"</rhs>
    </production>
    <production id="EnumeratedValue">
      <lhs>EnumeratedValue</lhs>
      <rhs><nonterminal
      def="#EnumerationIdentifier">EnumerationIdentifier</nonterminal></rhs>
    </production>
    <production id="CharStringValue">
      <lhs>CharStringValue</lhs>
      <rhs><nonterminal def="#Cstring">Cstring</nonterminal> |<sbr/>
      <nonterminal def="#Quadruple">Quadruple</nonterminal></rhs>
    </production>
    <production id="Quadruple">
      <lhs>Quadruple</lhs>
      <rhs><nonterminal def="#CharKeyword">CharKeyword</nonterminal>
      "(" <nonterminal def="#Group">Group</nonterminal> ","
      <nonterminal def="#Plane">Plane</nonterminal> "," <nonterminal
      def="#Row">Row</nonterminal> "," <nonterminal
      def="#Cell">Cell</nonterminal> ")"</rhs>
    </production>
    <production id="Group">
      <lhs>Group</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal></rhs>
    </production>
    <production id="Plane">
      <lhs>Plane</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal></rhs>
    </production>
    <production id="Row">
      <lhs>Row</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal></rhs>
    </production>
    <production id="Cell">
      <lhs>Cell</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal></rhs>
    </production>
    <production id="FloatValue">
      <lhs>FloatValue</lhs>
      <rhs><nonterminal
      def="#FloatDotNotation">FloatDotNotation</nonterminal> |<sbr/>
      <nonterminal
      def="#FloatENotation">FloatENotation</nonterminal></rhs>
    </production>
    <production id="FloatDotNotation">
      <lhs>FloatDotNotation</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal>
      <nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#DecimalNumber">DecimalNumber</nonterminal></rhs>
    </production>
    <production id="FloatENotation">
      <lhs>FloatENotation</lhs>
      <rhs><nonterminal def="#Number">Number</nonterminal>
      [<nonterminal def="#Dot">Dot</nonterminal> <nonterminal
      def="#DecimalNumber">DecimalNumber</nonterminal>] <nonterminal
      def="#Exponential">Exponential</nonterminal> [<nonterminal
      def="#Minus">Minus</nonterminal>] <nonterminal
      def="#Number">Number</nonterminal></rhs>
    </production>
    <production id="Exponential">
      <lhs>Exponential</lhs>
      <rhs>"E"</rhs>
    </production>
    <production id="ReferencedValue">
      <lhs>ReferencedValue</lhs>
      <rhs><nonterminal
      def="#ValueReference">ValueReference</nonterminal> [<nonterminal
      def="#ExtendedFieldReference">ExtendedFieldReference</nonterminal>]</rhs>
    </production>
    <production id="ValueReference">
      <lhs>ValueReference</lhs>
      <rhs>[<nonterminal
      def="#GlobalModuleId">GlobalModuleId</nonterminal> Dot]
      (<nonterminal
      def="#ConstIdentifier">ConstIdentifier</nonterminal> |<sbr/>
      <nonterminal
       def="#ExtConstIdentifier">ExtConstIdentifier</nonterminal>)
       |<sbr/> <nonterminal
       def="#ValueParIdentifier">ValueParIdentifier</nonterminal>
       |<sbr/> <nonterminal
       def="#ModuleParIdentifier">ModuleParIdentifier</nonterminal>
       |<sbr/> <nonterminal
      def="#VarIdentifier">VarIdentifier</nonterminal></rhs>
    </production>
    <production id="Number">
      <lhs>Number</lhs>
      <rhs>(<nonterminal def="#NonZeroNum">NonZeroNum</nonterminal>
      {<nonterminal def="#Num">Num</nonterminal>}) |<sbr/> "0"</rhs>
    </production>
    <production id="NonZeroNum">
      <lhs>NonZeroNum</lhs>
      <rhs>"1" |<sbr/> "2" |<sbr/> "3" |<sbr/> "4" |<sbr/> "5" |<sbr/>
      "6" |<sbr/> "7" |<sbr/> "8" |<sbr/> "9"</rhs>
    </production>
    <production id="DecimalNumber">
      <lhs>DecimalNumber</lhs>
      <rhs>{<nonterminal def="#Num">Num</nonterminal>}+</rhs>
    </production>
    <production id="Num">
      <lhs>Num</lhs>
      <rhs>"0" |<sbr/> <nonterminal
      def="#NonZeroNum">NonZeroNum</nonterminal></rhs>
    </production>
    <production id="Bstring">
      <lhs>Bstring</lhs>
      <rhs>"'" {<nonterminal def="#Bin">Bin</nonterminal>} "'"
      "B"</rhs>
    </production>
    <production id="Bin">
      <lhs>Bin</lhs>
      <rhs>"0" |<sbr/> "1"</rhs>
    </production>
    <production id="Hstring">
      <lhs>Hstring</lhs>
      <rhs>"'" {<nonterminal def="#Hex">Hex</nonterminal>} "'"
      "H"</rhs>
    </production>
    <production id="Hex">
      <lhs>Hex</lhs>
      <rhs><nonterminal def="#Num">Num</nonterminal> |<sbr/> "A"
      |<sbr/> "B" |<sbr/> "C" |<sbr/> "D" |<sbr/> "E" |<sbr/>
      "F"|<sbr/> "a" |<sbr/> "b" |<sbr/> "c" |<sbr/> "d" |<sbr/> "e"
      |<sbr/> "f"</rhs>
    </production>
    <production id="Ostring">
      <lhs>Ostring</lhs>
      <rhs>"'" {<nonterminal def="#Oct">Oct</nonterminal>} "'"
      "O"</rhs>
    </production>
    <production id="Oct">
      <lhs>Oct</lhs>
      <rhs><nonterminal def="#Hex">Hex</nonterminal> <nonterminal
      def="#Hex">Hex</nonterminal></rhs>
    </production>
    <production id="Cstring">
      <lhs>Cstring</lhs>
      <rhs>""" {<nonterminal def="#Char">Char</nonterminal>} """</rhs>
    </production>
    <production id="Char">
      <lhs>Char</lhs>
      <rhs><lineannotation><emphasis>Reference</emphasis>: A
      character defined by the
      relevant CharacterString type. For charstring a character from
      the character set defined in <citetitle>ISO/IEC
      646</citetitle>. For universal
      charstring a character from any character set defined in
      <citetitle>ISO/IEC 10646</citetitle></lineannotation></rhs>
    </production>
    <production id="Identifier">
      <lhs>Identifier</lhs>
      <rhs><nonterminal def="#Alpha">Alpha</nonterminal>{<nonterminal
      def="#AlphaNum">AlphaNum</nonterminal> |<sbr/> <nonterminal
      def="#Underscore">Underscore</nonterminal>}</rhs>
    </production>
    <production id="Alpha">
      <lhs>Alpha</lhs>
      <rhs><nonterminal def="#UpperAlpha">UpperAlpha</nonterminal>
      |<sbr/> <nonterminal
      def="#LowerAlpha">LowerAlpha</nonterminal></rhs>
    </production>
    <production id="AlphaNum">
      <lhs>AlphaNum</lhs>
      <rhs><nonterminal def="#Alpha">Alpha</nonterminal> |<sbr/>
      Num</rhs>
    </production>
    <production id="UpperAlpha">
      <lhs>UpperAlpha</lhs>
      <rhs>"A" |<sbr/> "B" |<sbr/> "C" |<sbr/> "D" |<sbr/> "E" |<sbr/>
      "F" |<sbr/> "G" |<sbr/> "H" |<sbr/> "I" |<sbr/> "J" |<sbr/> "K"
      |<sbr/> "L" |<sbr/> "M" |<sbr/> "N" |<sbr/> "O" |<sbr/> "P"
      |<sbr/> "Q" |<sbr/> "R" |<sbr/> "S" |<sbr/> "T" |<sbr/> "U"
      |<sbr/> "V" |<sbr/> "W" |<sbr/> "X" |<sbr/> "Y" |<sbr/>
      "Z"</rhs>
    </production>
    <production id="LowerAlpha">
      <lhs>LowerAlpha</lhs>
      <rhs>"a" |<sbr/> "b" |<sbr/> "c" |<sbr/> "d" |<sbr/> "e" |<sbr/>
      "f" |<sbr/> "g" |<sbr/> "h" |<sbr/> "i" |<sbr/> "j" |<sbr/> "k"
      |<sbr/> "l" |<sbr/> "m" |<sbr/> "n" |<sbr/> "o" |<sbr/> "p"
      |<sbr/> "q" |<sbr/> "r" |<sbr/> "s" |<sbr/> "t" |<sbr/> "u"
      |<sbr/> "v" |<sbr/> "w" |<sbr/> "x" |<sbr/> "y" |<sbr/>
      "z"</rhs>
    </production>
    <production id="ExtendedAlphaNum">
      <lhs>ExtendedAlphaNum</lhs>
      <rhs><lineannotation><emphasis>Reference</emphasis>: A
      graphical character from the
      BASIC LATIN or from the LATIN-1 SUPPLEMENT character sets
      defined in <citetitle>ISO/IEC 10646</citetitle> (characters from
      char (0,0,0,33) to
      char (0,0,0,126), from char (0,0,0,161) to char (0,0,0,172) and
      from char (0,0,0,174) to char (0,0,0,255)</lineannotation></rhs>
    </production>
    <production id="FreeText">
      <lhs>FreeText</lhs>
      <rhs>""" {<nonterminal
      def="#ExtendedAlphaNum">ExtendedAlphaNum</nonterminal>}
      """</rhs>
    </production>
    <production id="AddressValue">
      <lhs>AddressValue</lhs>
      <rhs>"null"</rhs>
    </production>
    <production id="OmitValue">
      <lhs>OmitValue</lhs>
      <rhs><nonterminal
      def="#OmitKeyword">OmitKeyword</nonterminal></rhs>
    </production>
    <production id="OmitKeyword">
      <lhs>OmitKeyword</lhs>
      <rhs>"omit"</rhs>
    </production>
  </productionset>
  <productionset>
    <title>5 Parameterization</title>
    <production id="InParKeyword">
      <lhs>InParKeyword</lhs>
      <rhs>"in"</rhs>
    </production>
    <production id="OutParKeyword">
      <lhs>OutParKeyword</lhs>
      <rhs>"out"</rhs>
    </production>
    <production id="InOutParKeyword">
      <lhs>InOutParKeyword</lhs>
      <rhs>"inout"</rhs>
    </production>
    <production id="FormalValuePar">
      <lhs>FormalValuePar</lhs>
      <rhs>[(<nonterminal
      def="#InParKeyword">InParKeyword</nonterminal> |<sbr/>
      <nonterminal
       def="#InOutParKeyword">InOutParKeyword</nonterminal> |<sbr/>
       <nonterminal def="#OutParKeyword">OutParKeyword</nonterminal>)]
       <nonterminal def="#Type">Type</nonterminal> <nonterminal
      def="#ValueParIdentifier">ValueParIdentifier</nonterminal></rhs>
    </production>
    <production id="ValueParIdentifier">
      <lhs>ValueParIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="FormalPortPar">
      <lhs>FormalPortPar</lhs>
      <rhs>[<nonterminal
      def="#InOutParKeyword">InOutParKeyword</nonterminal>]
      <nonterminal
      def="#PortTypeIdentifier">PortTypeIdentifier</nonterminal>
      <nonterminal
      def="#PortParIdentifier">PortParIdentifier</nonterminal></rhs>
    </production>
    <production id="PortParIdentifier">
      <lhs>PortParIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="FormalTimerPar">
      <lhs>FormalTimerPar</lhs>
      <rhs>[<nonterminal
      def="#InOutParKeyword">InOutParKeyword</nonterminal>]
      <nonterminal def="#TimerKeyword">TimerKeyword</nonterminal>
      <nonterminal
      def="#TimerParIdentifier">TimerParIdentifier</nonterminal></rhs>
    </production>
    <production id="TimerParIdentifier">
      <lhs>TimerParIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="FormalTemplatePar">
      <lhs>FormalTemplatePar</lhs>
      <rhs>[<nonterminal
      def="#InParKeyword">InParKeyword</nonterminal>] <nonterminal
      def="#TemplateKeyword">TemplateKeyword</nonterminal>
      <nonterminal def="#Type">Type</nonterminal> <nonterminal
      def="#TemplateParIdentifier">TemplateParIdentifier</nonterminal></rhs>
    </production>
    <production id="TemplateParIdentifier">
      <lhs>TemplateParIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>6 With statement</title>
    <production id="WithStatement">
      <lhs>WithStatement</lhs>
      <rhs><nonterminal def="#WithKeyword">WithKeyword</nonterminal>
      <nonterminal
      def="#WithAttribList">WithAttribList</nonterminal></rhs>
    </production>
    <production id="WithKeyword">
      <lhs>WithKeyword</lhs>
      <rhs>"with"</rhs>
    </production>
    <production id="WithAttribList">
      <lhs>WithAttribList</lhs>
      <rhs>"{" <nonterminal
      def="#MultiWithAttrib">MultiWithAttrib</nonterminal> "}"</rhs>
    </production>
    <production id="MultiWithAttrib">
      <lhs>MultiWithAttrib</lhs>
      <rhs>{<nonterminal
      def="#SingleWithAttrib">SingleWithAttrib</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+</rhs>
    </production>
    <production id="SingleWithAttrib">
      <lhs>SingleWithAttrib</lhs>
      <rhs><nonterminal
      def="#AttribKeyword">AttribKeyword</nonterminal> [<nonterminal
      def="#OverrideKeyword">OverrideKeyword</nonterminal>]
      [<nonterminal
      def="#AttribQualifier">AttribQualifier</nonterminal>]
      <nonterminal def="#AttribSpec">AttribSpec</nonterminal></rhs>
    </production>
    <production id="AttribKeyword">
      <lhs>AttribKeyword</lhs>
      <rhs><nonterminal
      def="#EncodeKeyword">EncodeKeyword</nonterminal> |<sbr/>
      <nonterminal
       def="#VariationKeyword">VariationKeyword</nonterminal> |<sbr/>
       <nonterminal def="#DisplayKeyword">DisplayKeyword</nonterminal>
       |<sbr/> <nonterminal
      def="#ExtensionKeyword">ExtensionKeyword</nonterminal></rhs>
    </production>
    <production id="EncodeKeyword">
      <lhs>EncodeKeyword</lhs>
      <rhs>"encode"</rhs>
    </production>
    <production id="VariationKeyword">
      <lhs>VariationKeyword</lhs>
      <rhs>"variant"</rhs>
    </production>
    <production id="DisplayKeyword">
      <lhs>DisplayKeyword</lhs>
      <rhs>"display"</rhs>
    </production>
    <production id="ExtensionKeyword">
      <lhs>ExtensionKeyword</lhs>
      <rhs>"extension"</rhs>
    </production>
    <production id="OverrideKeyword">
      <lhs>OverrideKeyword</lhs>
      <rhs>"override"</rhs>
    </production>
    <production id="AttribQualifier">
      <lhs>AttribQualifier</lhs>
      <rhs>"(" <nonterminal
      def="#DefOrFieldRefList">DefOrFieldRefList</nonterminal>
      ")"</rhs>
    </production>
    <production id="DefOrFieldRefList">
      <lhs>DefOrFieldRefList</lhs>
      <rhs><nonterminal
      def="#DefOrFieldRef">DefOrFieldRef</nonterminal> {","
      <nonterminal
      def="#DefOrFieldRef">DefOrFieldRef</nonterminal>}</rhs>
    </production>
    <production id="DefOrFieldRef">
      <lhs>DefOrFieldRef</lhs>
      <rhs><nonterminal
      def="#DefinitionRef">DefinitionRef</nonterminal> |<sbr/>
      <nonterminal def="#FieldReference">FieldReference</nonterminal>
      |<sbr/> <nonterminal def="#AllRef">AllRef</nonterminal> |<sbr/>
      <nonterminal def="#PredefinedType">PredefinedType</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal def="#DefOrFieldRef">DefOrFieldRef</nonterminal>
      must refer to a definition or field which is within the module,
      group or definition to which the with statement is
      associated</lineannotation></rhs>
    </production>
    <production id="DefinitionRef">
      <lhs>DefinitionRef</lhs>
      <rhs><nonterminal
      def="#StructTypeIdentifier">StructTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#EnumTypeIdentifier">EnumTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#PortTypeIdentifier">PortTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#ComponentTypeIdentifier">ComponentTypeIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#SubTypeIdentifier">SubTypeIdentifier</nonterminal> |<sbr/>
      <nonterminal
       def="#ConstIdentifier">ConstIdentifier</nonterminal> |<sbr/>
       <nonterminal
       def="#TemplateIdentifier">TemplateIdentifier</nonterminal>
       |<sbr/> <nonterminal
       def="#AltstepIdentifier">AltstepIdentifier</nonterminal> |<sbr/>
       <nonterminal
       def="#TestcaseIdentifier">TestcaseIdentifier</nonterminal>
       |<sbr/> <nonterminal
       def="#FunctionIdentifier">FunctionIdentifier</nonterminal>
       |<sbr/> <nonterminal
       def="#SignatureIdentifier">SignatureIdentifier</nonterminal>
       |<sbr/> <nonterminal
       def="#VarIdentifier">VarIdentifier</nonterminal> |<sbr/>
       <nonterminal
	def="#TimerIdentifier">TimerIdentifier</nonterminal> |<sbr/>
	<nonterminal def="#PortIdentifier">PortIdentifier</nonterminal>
	|<sbr/> <nonterminal
	def="#ModuleParIdentifier">ModuleParIdentifier</nonterminal>
	|<sbr/> <nonterminal
      def="#FullGroupIdentifier">FullGroupIdentifier</nonterminal></rhs>
    </production>
    <production id="AllRef">
      <lhs>AllRef</lhs>
      <rhs>( <nonterminal
      def="#GroupKeyword">GroupKeyword</nonterminal> <nonterminal
      def="#AllKeyword">AllKeyword</nonterminal> [<nonterminal
      def="#ExceptKeyword">ExceptKeyword</nonterminal> <nonterminal
      def="#BeginChar">BeginChar</nonterminal> <nonterminal
      def="#GroupRefList">GroupRefList</nonterminal> <nonterminal
      def="#EndChar">EndChar</nonterminal>]) |<sbr/> ( <nonterminal
      def="#TypeDefKeyword">TypeDefKeyword</nonterminal> <nonterminal
      def="#AllKeyword">AllKeyword</nonterminal> [<nonterminal
      def="#ExceptKeyword">ExceptKeyword</nonterminal> <nonterminal
      def="#BeginChar">BeginChar</nonterminal> <nonterminal
      def="#TypeRefList">TypeRefList</nonterminal>] <nonterminal
      def="#EndChar">EndChar</nonterminal>) |<sbr/> ( <nonterminal
      def="#TemplateKeyword">TemplateKeyword</nonterminal>
      <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
      [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      <nonterminal
       def="#TemplateRefList">TemplateRefList</nonterminal>]
       <nonterminal def="#EndChar">EndChar</nonterminal>) |<sbr/> (
       <nonterminal def="#ConstKeyword">ConstKeyword</nonterminal>
       <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
       [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
       <nonterminal def="#BeginChar">BeginChar</nonterminal>
       <nonterminal def="#ConstRefList">ConstRefList</nonterminal>]
       <nonterminal def="#EndChar">EndChar</nonterminal>) |<sbr/> (
       <nonterminal def="#AltstepKeyword">AltstepKeyword</nonterminal>
       <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
       [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
       <nonterminal def="#BeginChar">BeginChar</nonterminal>
       <nonterminal def="#AltstepRefList">AltstepRefList</nonterminal>]
       <nonterminal def="#EndChar">EndChar</nonterminal>) |<sbr/> (
       <nonterminal
       def="#TestcaseKeyword">TestcaseKeyword</nonterminal>
       <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
       [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
       <nonterminal def="#BeginChar">BeginChar</nonterminal>
       <nonterminal
	def="#TestcaseRefList">TestcaseRefList</nonterminal>]
	<nonterminal def="#EndChar">EndChar</nonterminal>) |<sbr/> (
	<nonterminal
	def="#FunctionKeyword">FunctionKeyword</nonterminal>
	<nonterminal def="#AllKeyword">AllKeyword</nonterminal>
	[<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
	<nonterminal def="#BeginChar">BeginChar</nonterminal>
	<nonterminal
	 def="#FunctionRefList">FunctionRefList</nonterminal>]
	 <nonterminal def="#EndChar">EndChar</nonterminal>) |<sbr/> (
	 <nonterminal
	 def="#SignatureKeyword">SignatureKeyword</nonterminal>
	 <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
	 [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
	 <nonterminal def="#BeginChar">BeginChar</nonterminal>
	 <nonterminal
	  def="#SignatureRefList">SignatureRefList</nonterminal>]
	  <nonterminal def="#EndChar">EndChar</nonterminal>) |<sbr/> (
	  <nonterminal
	  def="#ModuleParKeyword">ModuleParKeyword</nonterminal>
	  <nonterminal def="#AllKeyword">AllKeyword</nonterminal>
	  [<nonterminal def="#ExceptKeyword">ExceptKeyword</nonterminal>
	  <nonterminal def="#BeginChar">BeginChar</nonterminal>
	  <nonterminal
	   def="#ModuleParRefList">ModuleParRefList</nonterminal>]
      <nonterminal def="#EndChar">EndChar</nonterminal>)</rhs>
    </production>
    <production id="AttribSpec">
      <lhs>AttribSpec</lhs>
      <rhs><nonterminal def="#FreeText">FreeText</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>7 Behaviour statements</title>
    <production id="BehaviourStatements">
      <lhs>BehaviourStatements</lhs>
      <rhs><nonterminal
      def="#TestcaseInstance">TestcaseInstance</nonterminal> |<sbr/>
      <nonterminal
      def="#FunctionInstance">FunctionInstance</nonterminal> |<sbr/>
      <nonterminal
      def="#ReturnStatement">ReturnStatement</nonterminal> |<sbr/>
      <nonterminal def="#AltConstruct">AltConstruct</nonterminal>
      |<sbr/> <nonterminal
      def="#InterleavedConstruct">InterleavedConstruct</nonterminal>
      |<sbr/> <nonterminal
      def="#LabelStatement">LabelStatement</nonterminal> |<sbr/>
      <nonterminal def="#GotoStatement">GotoStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#RepeatStatement">RepeatStatement</nonterminal> |<sbr/>
      <nonterminal
      def="#DeactivateStatement">DeactivateStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#AltstepInstance">AltstepInstance</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal
      def="#TestcaseInstance">TestcaseInstance</nonterminal> shall not
      be called from within an existing executing testcase or function
      chain called from a testcase i.e., testcases can only be
      instantiated from the control part or from functions directly
      called from the control part</lineannotation></rhs>
    </production>
    <production id="VerdictStatements">
      <lhs>VerdictStatements</lhs>
      <rhs><nonterminal
      def="#SetLocalVerdict">SetLocalVerdict</nonterminal></rhs>
    </production>
    <production id="VerdictOps">
      <lhs>VerdictOps</lhs>
      <rhs><nonterminal
      def="#GetLocalVerdict">GetLocalVerdict</nonterminal></rhs>
    </production>
    <production id="SetLocalVerdict">
      <lhs>SetLocalVerdict</lhs>
      <rhs><nonterminal
      def="#SetVerdictKeyword">SetVerdictKeyword</nonterminal> "("
      <nonterminal
      def="#SingleExpression">SingleExpression</nonterminal> ")"
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal
      def="#SingleExpression">SingleExpression</nonterminal> must
      resolve to a value of type verdict</lineannotation>
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal
      def="#SetLocalVerdict">SetLocalVerdict</nonterminal> shall not
      be used to assign the Value error</lineannotation></rhs>
    </production>
    <production id="SetVerdictKeyword">
      <lhs>SetVerdictKeyword</lhs>
      <rhs>"setverdict"</rhs>
    </production>
    <production id="GetLocalVerdict">
      <lhs>GetLocalVerdict</lhs>
      <rhs>"getverdict"</rhs>
    </production>
    <production id="SUTStatements">
      <lhs>SUTStatements</lhs>
      <rhs><nonterminal
      def="#ActionKeyword">ActionKeyword</nonterminal> "("
      (<nonterminal def="#FreeText">FreeText</nonterminal> |<sbr/>
      <nonterminal
       def="#TemplateRefWithParList">TemplateRefWithParList</nonterminal>)
      ")"</rhs>
    </production>
    <production id="ActionKeyword">
      <lhs>ActionKeyword</lhs>
      <rhs>"action"</rhs>
    </production>
    <production id="ReturnStatement">
      <lhs>ReturnStatement</lhs>
      <rhs><nonterminal
      def="#ReturnKeyword">ReturnKeyword</nonterminal> [<nonterminal
      def="#Expression">Expression</nonterminal>]</rhs>
    </production>
    <production id="AltConstruct">
      <lhs>AltConstruct</lhs>
      <rhs><nonterminal def="#AltKeyword">AltKeyword</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      <nonterminal def="#AltGuardList">AltGuardList</nonterminal>
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="AltKeyword">
      <lhs>AltKeyword</lhs>
      <rhs>"alt"</rhs>
    </production>
    <production id="AltGuardList">
      <lhs>AltGuardList</lhs>
      <rhs>{<nonterminal
      def="#GuardStatement">GuardStatement</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]}+
      [<nonterminal def="#ElseStatement">ElseStatement</nonterminal>
      [<nonterminal def="#SemiColon">SemiColon</nonterminal>]]</rhs>
    </production>
    <production id="GuardStatement">
      <lhs>GuardStatement</lhs>
      <rhs><nonterminal
      def="#AltGuardChar">AltGuardChar</nonterminal> (<nonterminal
      def="#AltstepInstance">AltstepInstance</nonterminal> |<sbr/>
      <nonterminal def="#GuardOp">GuardOp</nonterminal> <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal>)</rhs>
    </production>
    <production id="ElseStatement">
      <lhs>ElseStatement</lhs>
      <rhs>"["<nonterminal
      def="#ElseKeyword">ElseKeyword</nonterminal> "]" <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
    <production id="AltGuardChar">
      <lhs>AltGuardChar</lhs>
      <rhs>"[" [<nonterminal
      def="#BooleanExpression">BooleanExpression</nonterminal>]
      "]"</rhs>
    </production>
    <production id="GuardOp">
      <lhs>GuardOp</lhs>
      <rhs><nonterminal
      def="#TimeoutStatement">TimeoutStatement</nonterminal> |<sbr/>
      <nonterminal
      def="#ReceiveStatement">ReceiveStatement</nonterminal> |<sbr/>
      <nonterminal
      def="#TriggerStatement">TriggerStatement</nonterminal> |<sbr/>
      <nonterminal
      def="#GetCallStatement">GetCallStatement</nonterminal> |<sbr/>
      <nonterminal def="#CatchStatement">CatchStatement</nonterminal>
      |<sbr/> <nonterminal
      def="#CheckStatement">CheckStatement</nonterminal> |<sbr/>
      <nonterminal
      def="#GetReplyStatement">GetReplyStatement</nonterminal> |<sbr/>
      <nonterminal def="#DoneStatement">DoneStatement</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#GuardOp">GuardOp</nonterminal> used within
      the module control part. May only contain the
      timeoutStatement</lineannotation></rhs>
    </production>
    <production id="InterleavedConstruct">
      <lhs>InterleavedConstruct</lhs>
      <rhs><nonterminal
      def="#InterleavedKeyword">InterleavedKeyword</nonterminal>
      <nonterminal def="#BeginChar">BeginChar</nonterminal>
      <nonterminal def="#InterleavedGuardList">InterleavedGuardList</nonterminal>
      <nonterminal def="#EndChar">EndChar</nonterminal></rhs>
    </production>
    <production id="InterleavedKeyword">
      <lhs>InterleavedKeyword</lhs>
      <rhs>"interleave"</rhs>
    </production>
    <production id="InterleavedGuardList">
      <lhs>InterleavedGuardList</lhs>
      <rhs>{<nonterminal
      def="#InterleavedGuardElement">InterleavedGuardElement</nonterminal>
      [<nonterminal
      def="#SemiColon">SemiColon</nonterminal>]}+</rhs>
    </production>
    <production id="InterleavedGuardElement">
      <lhs>InterleavedGuardElement</lhs>
      <rhs><nonterminal
      def="#InterleavedGuard">InterleavedGuard</nonterminal>
      <nonterminal
      def="#InterleavedAction">InterleavedAction</nonterminal></rhs>
    </production>
    <production id="InterleavedGuard">
      <lhs>InterleavedGuard</lhs>
      <rhs>"[" "]" <nonterminal
      def="#GuardOp">GuardOp</nonterminal></rhs>
    </production>
    <production id="InterleavedAction">
      <lhs>InterleavedAction</lhs>
      <rhs><nonterminal
      def="#StatementBlock">StatementBlock</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: the
      <nonterminal def="#StatementBlock">StatementBlock</nonterminal>
      may not contain loop statements, goto, activate, deactivate,
      stop, return or calls to functions</lineannotation></rhs>
    </production>
    <production id="LabelStatement">
      <lhs>LabelStatement</lhs>
      <rhs><nonterminal
      def="#LabelKeyword">LabelKeyword</nonterminal> <nonterminal
      def="#LabelIdentifier">LabelIdentifier</nonterminal></rhs>
    </production>
    <production id="LabelKeyword">
      <lhs>LabelKeyword</lhs>
      <rhs>"label"</rhs>
    </production>
    <production id="LabelIdentifier">
      <lhs>LabelIdentifier</lhs>
      <rhs><nonterminal
      def="#Identifier">Identifier</nonterminal></rhs>
    </production>
    <production id="GotoStatement">
      <lhs>GotoStatement</lhs>
      <rhs><nonterminal def="#GotoKeyword">GotoKeyword</nonterminal>
      <nonterminal
      def="#LabelIdentifier">LabelIdentifier</nonterminal></rhs>
    </production>
    <production id="GotoKeyword">
      <lhs>GotoKeyword</lhs>
      <rhs>"goto"</rhs>
    </production>
    <production id="RepeatStatement">
      <lhs>RepeatStatement</lhs>
      <rhs>"repeat"</rhs>
    </production>
    <production id="ActivateOp">
      <lhs>ActivateOp</lhs>
      <rhs><nonterminal
      def="#ActivateKeyword">ActivateKeyword</nonterminal> "("
      <nonterminal
      def="#AltstepInstance">AltstepInstance</nonterminal> ")"</rhs>
    </production>
    <production id="ActivateKeyword">
      <lhs>ActivateKeyword</lhs>
      <rhs>"activate"</rhs>
    </production>
    <production id="DeactivateStatement">
      <lhs>DeactivateStatement</lhs>
      <rhs><nonterminal
      def="#DeactivateKeyword">DeactivateKeyword</nonterminal> ["("
      <nonterminal def="#Expression">Expression</nonterminal> ")"]
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#Expression">Expression</nonterminal> shall
      evaluate to a value of default type</lineannotation></rhs>
    </production>
    <production id="DeactivateKeyword">
      <lhs>DeactivateKeyword</lhs>
      <rhs>"deactivate"</rhs>
    </production>
  </productionset>
  <productionset>
    <title>8 Basic statements</title>
    <production id="BasicStatements">
      <lhs>BasicStatements</lhs>
      <rhs><nonterminal def="#Assignment">Assignment</nonterminal>
      |<sbr/> <nonterminal
      def="#LogStatement">LogStatement</nonterminal> |<sbr/>
      <nonterminal def="#LoopConstruct">LoopConstruct</nonterminal>
      |<sbr/> <nonterminal
      def="#ConditionalConstruct">ConditionalConstruct</nonterminal></rhs>
    </production>
    <production id="Expression">
      <lhs>Expression</lhs>
      <rhs><nonterminal
      def="#SingleExpression">SingleExpression</nonterminal> |<sbr/>
      <nonterminal
      def="#CompoundExpression">CompoundExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal def="#Expression">Expression</nonterminal> shall
      not contain Configuration, activate operation or verdict
      operations within the module control part</lineannotation></rhs>
    </production>
    <production id="CompoundExpression">
      <lhs>CompoundExpression</lhs>
      <rhs><nonterminal
      def="#FieldExpressionList">FieldExpressionList</nonterminal>
      |<sbr/> <nonterminal
      def="#ArrayExpression">ArrayExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: Within
      <nonterminal
      def="#CompoundExpression">CompoundExpression</nonterminal> the
      <nonterminal
      def="#ArrayExpression">ArrayExpression</nonterminal> can be used
      for Arrays, record, record of and set of
      types.</lineannotation></rhs>
    </production>
    <production id="FieldExpressionList">
      <lhs>FieldExpressionList</lhs>
      <rhs>"{" <nonterminal
      def="#FieldExpressionSpec">FieldExpressionSpec</nonterminal>
      {"," <nonterminal
      def="#FieldExpressionSpec">FieldExpressionSpec</nonterminal>}
      "}"</rhs>
    </production>
    <production id="FieldExpressionSpec">
      <lhs>FieldExpressionSpec</lhs>
      <rhs><nonterminal
      def="#FieldReference">FieldReference</nonterminal>
      <nonterminal
      def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal def="#Expression">Expression</nonterminal></rhs>
    </production>
    <production id="ArrayExpression">
      <lhs>ArrayExpression</lhs>
      <rhs>"{" [<nonterminal
      def="#ArrayElementExpressionList">ArrayElementExpressionList</nonterminal>]
      "}"</rhs>
    </production>
    <production id="ArrayElementExpressionList">
      <lhs>ArrayElementExpressionList</lhs>
      <rhs><nonterminal
      def="#NotUsedOrExpression">NotUsedOrExpression</nonterminal>
      {"," <nonterminal
      def="#NotUsedOrExpression">NotUsedOrExpression</nonterminal>}</rhs>
    </production>
    <production id="NotUsedOrExpression">
      <lhs>NotUsedOrExpression</lhs>
      <rhs><nonterminal def="#Expression">Expression</nonterminal>
      |<sbr/> <nonterminal
      def="#NotUsedSymbol">NotUsedSymbol</nonterminal></rhs>
    </production>
    <production id="ConstantExpression">
      <lhs>ConstantExpression</lhs>
      <rhs><nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      |<sbr/> <nonterminal
      def="#CompoundConstExpression">CompoundConstExpression</nonterminal></rhs>
    </production>
    <production id="SingleConstExpression">
      <lhs>SingleConstExpression</lhs>
      <rhs><nonterminal
      def="#SingleExpression">SingleExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal
      def="#SingleConstExpression">SingleConstExpression</nonterminal>
      shall not contain Variables or Module parameters and shall
      resolve to a constant Value at compile
      time</lineannotation></rhs>
    </production>
    <production id="BooleanExpression">
      <lhs>BooleanExpression</lhs>
      <rhs><nonterminal
      def="#SingleExpression">SingleExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>:
      <nonterminal
      def="#BooleanExpression">BooleanExpression</nonterminal> shall
      resolve to a Value of type <link
      linkend="tt_boolean">boolean</link></lineannotation></rhs>
    </production>
    <production id="CompoundConstExpression">
      <lhs>CompoundConstExpression</lhs>
      <rhs><nonterminal
      def="#FieldConstExpressionList">FieldConstExpressionList</nonterminal>
      |<sbr/> <nonterminal
      def="#ArrayConstExpression">ArrayConstExpression</nonterminal>
      <lineannotation><emphasis>Static semantics</emphasis>: Within
      <nonterminal
      def="#CompoundConstExpression">CompoundConstExpression</nonterminal>
      the <nonterminal
      def="#ArrayConstExpression">ArrayConstExpression</nonterminal>
      can be used for Arrays, record, record of and set of
      types.</lineannotation></rhs>
    </production>
    <production id="FieldConstExpressionList">
      <lhs>FieldConstExpressionList</lhs>
      <rhs>"{" <nonterminal
      def="#FieldConstExpressionSpec">FieldConstExpressionSpec</nonterminal>
      {"," <nonterminal
      def="#FieldConstExpressionSpec">FieldConstExpressionSpec</nonterminal>}
      "}"</rhs>
    </production>
    <production id="FieldConstExpressionSpec">
      <lhs>FieldConstExpressionSpec</lhs>
      <rhs><nonterminal
      def="#FieldReference">FieldReference</nonterminal>
      <nonterminal
      def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal def="#ConstantExpression">ConstantExpression</nonterminal></rhs>
    </production>
    <production id="ArrayConstExpression">
      <lhs>ArrayConstExpression</lhs>
      <rhs>"{" [<nonterminal
      def="#ArrayElementConstExpressionList">ArrayElementConstExpressionList</nonterminal>]
      "}"</rhs>
    </production>
    <production id="ArrayElementConstExpressionList">
      <lhs>ArrayElementConstExpressionList</lhs>
      <rhs><nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal>
      {"," <nonterminal
      def="#ConstantExpression">ConstantExpression</nonterminal>}</rhs>
    </production>
    <production id="Assignment">
      <lhs>Assignment</lhs>
      <rhs><nonterminal def="#VariableRef">VariableRef</nonterminal>
      <nonterminal
      def="#AssignmentChar">AssignmentChar</nonterminal>
      <nonterminal def="#Expression">Expression</nonterminal>
      <lineannotation><emphasis>Operational semantics</emphasis>: The
      <nonterminal def="#Expression">Expression</nonterminal> on the
      RHS of <nonterminal def="#Assignment">Assignment</nonterminal>
      shall evaluate to an explicit Value of the type of the
      LHS.</lineannotation></rhs>
    </production>
    <production id="SingleExpression">
      <lhs>SingleExpression</lhs>
      <rhs><nonterminal
      def="#SimpleExpression">SimpleExpression</nonterminal>
      {<nonterminal def="#LogicalOp">LogicalOp</nonterminal>
      <nonterminal
      def="#SimpleExpression">SimpleExpression</nonterminal>}
      <lineannotation><emphasis>Operational semantics</emphasis>: If
      both <nonterminal
      def="#SimpleExpression">SimpleExpressions</nonterminal> and the
      <nonterminal def="#LogicalOp">LogicalOp</nonterminal> exist then
      the <nonterminal
      def="#SimpleExpression">SimpleExpressions</nonterminal> shall
      evaluate to specific values of compatible
      types</lineannotation></rhs>
    </production>
    <production id="SimpleExpression">
      <lhs>SimpleExpression</lhs>
      <rhs>["not"] <nonterminal
      def="#SubExpression">SubExpression</nonterminal>
      <lineannotation><emphasis>Operational semantics</emphasis>:
      Operands of the not operator shall be of type <link
      linkend="tt_boolean">boolean</link> (TTCN or
      ASN.1) or derivatives of type <link
      linkend="tt_boolean">boolean</link></lineannotation></rhs>
    </production>
    <production id="SubExpression">
      <lhs>SubExpression</lhs> <rhs><nonterminal
      def="#PartialExpression">PartialExpression</nonterminal>
      [<nonterminal def="#RelOp">RelOp</nonterminal> <nonterminal
      def="#PartialExpression">PartialExpression</nonterminal>]
      <lineannotation><emphasis>Operational semantics</emphasis>: If
      both <nonterminal
      def="#PartialExpression">PartialExpressions</nonterminal> and
      the <nonterminal def="#RelOp">RelOp</nonterminal> exist then the
      <nonterminal
      def="#PartialExpression">PartialExpressions</nonterminal> shall
      evaluate to specific values of compatible
      types.</lineannotation> <lineannotation><emphasis>Operational
      semantics</emphasis>: If <nonterminal
      def="#RelOp">RelOp</nonterminal> is <literal>&lt;</literal>,
      <literal>></literal>, <literal>>=</literal>, or
      <literal>&lt;=</literal> then each <nonterminal
      def="#SubExpression">SubExpression</nonterminal> shall evaluate
      to a specific integer, Enumerated or float Value (these values
      can either be TTCN or ASN.1 values)</lineannotation></rhs>
    </production>
    <production id="PartialExpression">
      <lhs>PartialExpression</lhs>
      <rhs><nonterminal def="#Result">Result</nonterminal>
      [<nonterminal def="#ShiftOp">ShiftOp</nonterminal> <nonterminal
      def="#Result">Result</nonterminal>]
      <lineannotation><emphasis>Operational semantics</emphasis>:
      Each Result shall resolve to a specific Value. If more than one
      Result exists the right-hand operand shall be of type integer
      and if the <nonterminal def="#ShiftOp">ShiftOp</nonterminal> is
      <literal>&lt;&lt;</literal> or <literal>>></literal> then the
      left-hand operand shall resolve to
      either bitstring, hexstring or octetstring type. If the shift op
      is <literal>&lt;@</literal> or <literal>@></literal> then the
      left-hand operand shall be of type
      bitstring, hexstring, charstring or universal
      charstring</lineannotation></rhs>
    </production>
    <production id="Result">
      <lhs>Result</lhs>
      <rhs><nonterminal def="#SubResult">SubResult</nonterminal>
      {<nonterminal def="#BitOp">BitOp</nonterminal> <nonterminal
      def="#SubResult">SubResult</nonterminal>}
      <lineannotation><emphasis>Operational semantics</emphasis>: If
      both <nonterminal def="#SubResult">SubResults</nonterminal> and
      the <nonterminal def="#BitOp">BitOp</nonterminal> exist then the
      <nonterminal def="#SubResult">SubResults</nonterminal> shall
      evaluate to specific values of compatible
      types</lineannotation></rhs>
    </production>
    <production id="SubResult">
      <lhs>SubResult</lhs>
      <rhs>["not4b"] <nonterminal def="#Product">Product</nonterminal>
      <lineannotation><emphasis>Operational semantics</emphasis>: If
      the <literal>not4b</literal> operator exists, the operand shall
      be of type
      bitstring, octetstring or hexstring.</lineannotation></rhs>
    </production>
    <production id="Product">
      <lhs>Product</lhs>
      <rhs><nonterminal def="#Term">Term</nonterminal> {<nonterminal
      def="#AddOp">AddOp</nonterminal> <nonterminal
      def="#Term">Term</nonterminal>} <lineannotation><emphasis>Operational
      semantics</emphasis>: Each <nonterminal def="#Term">Term</nonterminal>
      shall resolve to a specific Value. If more than one
      <nonterminal def="#Term">Term</nonterminal> exists and the
      <nonterminal def="#AddOp">AddOp</nonterminal> resolves to
      <nonterminal def="#StringOp">StringOp</nonterminal> then the
      terms shall resolve to same type which shall be of bitstring,
      hexstring, octetstring, charstring or universal charstring.If
      more than one <nonterminal def="#Term">Term</nonterminal>
      exists and the <nonterminal def="#AddOp">AddOp</nonterminal>
      does not resolve to <nonterminal
      def="#StringOp">StringOp</nonterminal> then the <nonterminal
      def="#Term">Terms</nonterminal> shall both resolve to type
      integer or float.</lineannotation></rhs>
    </production>
    <production id="Term">
      <lhs>Term</lhs>
      <rhs><nonterminal def="#Factor">Factor</nonterminal>
      {<nonterminal def="#MultiplyOp">MultiplyOp</nonterminal>
      <nonterminal def="#Factor">Factor</nonterminal>}
      <lineannotation><emphasis>Operational semantics</emphasis>:
      Each <nonterminal def="#Factor">Factor</nonterminal> shall
      resolve to a specific Value. If more than one <nonterminal
      def="#Factor">Factor</nonterminal> exists then the <nonterminal
      def="#Factor">Factors</nonterminal> shall resolve to type
      integer or float.</lineannotation></rhs>
    </production>
    <production id="Factor">
      <lhs>Factor</lhs>
      <rhs>[<nonterminal def="#UnaryOp">UnaryOp</nonterminal>]
      <nonterminal def="#Primary">Primary</nonterminal>
      <lineannotation><emphasis>Operational semantics</emphasis>: The
      <nonterminal def="#Primary">Primary</nonterminal> shall resolve
      to a specific Value. If <nonterminal
      def="#UnaryOp">UnaryOp</nonterminal> exists and is "not" then
      <nonterminal def="#Primary">Primary</nonterminal> shall resolve
      to type <link linkend="tt_boolean">boolean</link> if the <nonterminal
      def="#UnaryOp">UnaryOp</nonterminal> is <literal>+</literal> or
      <literal>-</literal> then
      <nonterminal def="#Primary">Primary</nonterminal> shall resolve
      to type integer or float. If the <nonterminal
      def="#UnaryOp">UnaryOp</nonterminal> resolves to
      <literal>not4b</literal> then the
      Primary shall resolve to the type bitstring, hexstring or
      octetstring.</lineannotation></rhs>
    </production>
    <production id="Primary">
      <lhs>Primary</lhs>
      <rhs><nonterminal def="#OpCall">OpCall</nonterminal> |<sbr/>
      <nonterminal def="#Value">Value</nonterminal> |<sbr/> "("
      <nonterminal
      def="#SingleExpression">SingleExpression</nonterminal>
      ")"</rhs>
    </production>
    <production id="ExtendedFieldReference">
      <lhs>ExtendedFieldReference</lhs>
      <rhs>{(<nonterminal def="#Dot">Dot</nonterminal> (
      <nonterminal
      def="#StructFieldIdentifier">StructFieldIdentifier</nonterminal>
      |<sbr/> <nonterminal
      def="#ArrayOrBitRef">ArrayOrBitRef</nonterminal> |<sbr/>
      <nonterminal
       def="#TypeDefIdentifier">TypeDefIdentifier</nonterminal>))
       |<sbr/> <nonterminal
       def="#ArrayOrBitRef">ArrayOrBitRef</nonterminal> }+
       <lineannotation><emphasis>Operational semantics</emphasis>: The
       <nonterminal
       def="#TypeDefIdentifier">TypeDefIdentifier</nonterminal> shall
       be used only if the type of the <nonterminal
       def="#VarInstance">VarInstance</nonterminal> or <nonterminal
       def="#ReferencedValue">ReferencedValue</nonterminal> in which
       the <nonterminal
       def="#ExtendedFieldReference">ExtendedFieldReference</nonterminal>
      is used is anytype.</lineannotation></rhs>
    </production>
    <production id="OpCall">
      <lhs>OpCall</lhs>
      <rhs><nonterminal
      def="#ConfigurationOps">ConfigurationOps</nonterminal>
      |<sbr/> <nonterminal
      def="#VerdictOps">VerdictOps</nonterminal> |<sbr/>
      <nonterminal def="#TimerOps">TimerOps</nonterminal> |<sbr/>
      <nonterminal
      def="#TestcaseInstance">TestcaseInstance</nonterminal>
      |<sbr/> <nonterminal
      def="#FunctionInstance">FunctionInstance</nonterminal>
      |<sbr/> <nonterminal
      def="#TemplateOps">TemplateOps</nonterminal> |<sbr/>
      <nonterminal
      def="#ActivateOp">ActivateOp</nonterminal></rhs>
    </production>
    <production id="AddOp">
      <lhs>AddOp</lhs>
      <rhs>"+" |<sbr/> "-" |<sbr/> <nonterminal
      def="#StringOp">StringOp</nonterminal>
      <lineannotation><emphasis>Operational semantics</emphasis>:
      Operands of the <literal>+</literal> or <literal>-</literal>
      operators shall be of type integer or
      float (i.e., TTCN or ASN.1 predefined) or derivations of integer
      or float (i.e., subrange)</lineannotation></rhs>
    </production>
    <production id="MultiplyOp">
      <lhs>MultiplyOp</lhs>
      <rhs>"*" |<sbr/> "/" |<sbr/> "mod" |<sbr/> "rem"
      <lineannotation><emphasis>Operational semantics</emphasis>:
      Operands of the <literal>*</literal>, <literal>/</literal>,
      <literal>rem</literal> or <literal>mod</literal> operators shall
      be of type
      integer or float (i.e., TTCN or ASN.1 predefined) or derivations
      of integer or float (i.e., subrange).</lineannotation></rhs>
    </production>
    <production id="UnaryOp">
      <lhs>UnaryOp</lhs>
      <rhs>"+" |<sbr/> "-" <lineannotation><emphasis>Operational
      semantics</emphasis>: Operands of the <literal>+</literal> or
      <literal>-</literal> operators
      shall be of type integer or float (i.e., TTCN or ASN.1
      predefined) or derivations of integer or float (i.e.,
      subrange).</lineannotation></rhs>
    </production>
    <production id="RelOp">
      <lhs>RelOp</lhs>
      <rhs>"==" |<sbr/> "&lt;" |<sbr/> ">" |<sbr/> "!=" |<sbr/> ">="
      |<sbr/> "&lt;=" <lineannotation><emphasis>Operational
      semantics</emphasis>: the precedence of the operators is
      defined <link
      linkend="operator-precedence">here</link></lineannotation></rhs>
    </production>
    <production id="BitOp">
      <lhs>BitOp</lhs>
      <rhs>"and4b" |<sbr/> "xor4b" |<sbr/> "or4b"
      <lineannotation><emphasis>Operational semantics</emphasis>:
      Operands of the <literal>and4b</literal>,
      <literal>or4b</literal> or <literal>xor4b</literal> operator
      shall be of type
      bitstring, hexstring or octetstring (TTCN or ASN.1) or
      derivatives of these types.</lineannotation></rhs>
    </production>
    <production id="LogicalOp">
      <lhs>LogicalOp</lhs>
      <rhs>"and" |<sbr/> "xor" |<sbr/> "or"
      <lineannotation><emphasis>Operational semantics</emphasis>:
      Operands of the <literal>and</literal>, <literal>xor</literal>,
      or <literal>or</literal> operators shall be of type <link
      linkend="tt_boolean">boolean</link>
      (TTCN or ASN.1) or derivatives of type <link
      linkend="tt_boolean">boolean</link>.</lineannotation>
      <lineannotation><emphasis>Operational semantics</emphasis>: the
      precedence of the operators is defined <link
      linkend="operator-precedence">here</link></lineannotation></rhs>
    </production>
    <production id="StringOp">
      <lhs>StringOp</lhs>
      <rhs>"&amp;" <lineannotation><emphasis>Operational
      semantics</emphasis>: Operands of the <literal>&amp;</literal>
      operator shall be
      <link linkend="tt_bitstring">bitstring</link>, <link
      linkend="tt_hexstring">hexstring</link>,
      <link linkend="tt_octetstring">octetstring</link> or <link
      linkend="tt_charstring">character string</link></lineannotation></rhs>
    </production>
    <production id="ShiftOp">
      <lhs>ShiftOp</lhs>
      <rhs>"&lt;&lt;" |<sbr/> ">>" |<sbr/> "&lt;@" |<sbr/>
      "@>"</rhs>
    </production>
    <production id="LogStatement">
      <lhs>LogStatement</lhs>
      <rhs><nonterminal def="#LogKeyword">LogKeyword</nonterminal>
      "(" [<nonterminal def="#FreeText">FreeText</nonterminal>]
      ")"</rhs>
    </production>
    <production id="LogKeyword">
      <lhs>LogKeyword</lhs>
      <rhs>"log"</rhs>
    </production>
    <production id="LoopConstruct">
      <lhs>LoopConstruct</lhs>
      <rhs><nonterminal
      def="#ForStatement">ForStatement</nonterminal> |<sbr/>
      <nonterminal
       def="#WhileStatement">WhileStatement</nonterminal> |<sbr/>
       <nonterminal
      def="#DoWhileStatement">DoWhileStatement</nonterminal></rhs>
    </production>
    <production id="ForStatement">
      <lhs>ForStatement</lhs>
      <rhs><nonterminal def="#ForKeyword">ForKeyword</nonterminal>
      "(" <nonterminal def="#Initial">Initial</nonterminal>
      <nonterminal def="#SemiColon">SemiColon</nonterminal>
      <nonterminal def="#Final">Final</nonterminal> <nonterminal
      def="#SemiColon">SemiColon</nonterminal> <nonterminal
      def="#Step">Step</nonterminal> ")" <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
    <production id="ForKeyword">
      <lhs>ForKeyword</lhs>
      <rhs>"for"</rhs>
    </production>
    <production id="Initial">
      <lhs>Initial</lhs>
      <rhs><nonterminal
      def="#VarInstance">VarInstance</nonterminal> |<sbr/>
      <nonterminal
      def="#Assignment">Assignment</nonterminal></rhs>
    </production>
    <production id="Final">
      <lhs>Final</lhs>
      <rhs><nonterminal
      def="#BooleanExpression">BooleanExpression</nonterminal></rhs>
    </production>
    <production id="Step">
      <lhs>Step</lhs>
      <rhs><nonterminal
      def="#Assignment">Assignment</nonterminal></rhs>
    </production>
    <production id="WhileStatement">
      <lhs>WhileStatement</lhs>
      <rhs><nonterminal
      def="#WhileKeyword">WhileKeyword</nonterminal> "("
      <nonterminal
       def="#BooleanExpression">BooleanExpression</nonterminal> ")"
       <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
    <production id="WhileKeyword">
      <lhs>WhileKeyword</lhs>
      <rhs>"while"</rhs>
    </production>
    <production id="DoWhileStatement">
      <lhs>DoWhileStatement</lhs>
      <rhs><nonterminal def="#DoKeyword">DoKeyword</nonterminal>
      <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal>
      <nonterminal def="#WhileKeyword">WhileKeyword</nonterminal>
      "(" <nonterminal
      def="#BooleanExpression">BooleanExpression</nonterminal>
      ")"</rhs>
    </production>
    <production id="DoKeyword">
      <lhs>DoKeyword</lhs>
      <rhs>"do"</rhs>
    </production>
    <production id="ConditionalConstruct">
      <lhs>ConditionalConstruct</lhs>
      <rhs><nonterminal def="#IfKeyword">IfKeyword</nonterminal>
      "(" <nonterminal
      def="#BooleanExpression">BooleanExpression</nonterminal> ")"
      <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal>
      {<nonterminal
      def="#ElseIfClause">ElseIfClause</nonterminal>}
      [<nonterminal
      def="#ElseClause">ElseClause</nonterminal>]</rhs>
    </production>
    <production id="IfKeyword">
      <lhs>IfKeyword</lhs>
      <rhs>"if"</rhs>
    </production>
    <production id="ElseIfClause">
      <lhs>ElseIfClause</lhs>
      <rhs><nonterminal
      def="#ElseKeyword">ElseKeyword</nonterminal> <nonterminal
      def="#IfKeyword">IfKeyword</nonterminal> "(" <nonterminal
      def="#BooleanExpression">BooleanExpression</nonterminal> ")"
      <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
    <production id="ElseKeyword">
      <lhs>ElseKeyword</lhs>
      <rhs>"else"</rhs>
    </production>
    <production id="ElseClause">
      <lhs>ElseClause</lhs>
      <rhs><nonterminal
      def="#ElseKeyword">ElseKeyword</nonterminal> <nonterminal
      def="#StatementBlock">StatementBlock</nonterminal></rhs>
    </production>
  </productionset>
  <productionset>
    <title>9 Miscellaneous productions</title>
    <production id="Dot">
      <lhs>Dot</lhs>
      <rhs>"."</rhs>
    </production>
    <production id="Dash">
      <lhs>Dash</lhs>
      <rhs>"-"</rhs>
    </production>
    <production id="Minus">
      <lhs>Minus</lhs>
      <rhs><nonterminal def="#Dash">Dash</nonterminal></rhs>
    </production>
    <production id="SemiColon">
      <lhs>SemiColon</lhs>
      <rhs>";"</rhs>
    </production>
    <production id="Colon">
      <lhs>Colon</lhs>
      <rhs>":"</rhs>
    </production>
    <production id="Underscore">
      <lhs>Underscore</lhs>
      <rhs>"_"</rhs>
    </production>
    <production id="BeginChar">
      <lhs>BeginChar</lhs>
      <rhs>"{"</rhs>
    </production>
    <production id="EndChar">
      <lhs>EndChar</lhs>
      <rhs>"}"</rhs>
    </production>
    <production id="AssignmentChar">
      <lhs>AssignmentChar</lhs>
      <rhs>":="</rhs>
    </production>
  </productionset>

  <table pgwide="1">
    <title>Overview of TTCN-3 types</title>
    <tgroup cols="3">
      <colspec align="left"/>
      <colspec align="left"/>
      <colspec align="center"/>
      <thead>
	<row>
	  <entry align="center">Class of type</entry>
	  <entry align="center">Keyword</entry>
	  <entry align="center">Sub-type</entry>
	</row>
      </thead>
      <tbody>
	<row id="tt_integer">
	  <entry morerows="6" valign="top">Simple basic types</entry>
	  <entry><link linkend="IntegerKeyword">integer</link></entry>
	  <entry>range, list</entry>
	</row>
	<row id="tt_char">
	  <entry><link linkend="CharKeyword">char</link></entry>
	  <entry>range, list</entry>
	</row>
	<row id="tt_universal_char">
	  <entry><link linkend="UniversalChar">universal
	  char</link></entry>
	  <entry>range, list</entry>
	</row>
	<row id="tt_float">
	  <entry><link linkend="FloatKeyword">float</link></entry>
	  <entry>range, list</entry>
	</row>
	<row id="tt_boolean">
	  <entry><link linkend="BooleanKeyword">boolean</link></entry>
	  <entry>list</entry>
	</row>
	<row id="tt_objid">
	  <entry><link
	  linkend="ObjectIdentifierKeyword">objid</link></entry>
	  <entry>list</entry>
	</row>
	<row id="tt_verdicttype">
	  <entry><link
	  linkend="VerdictTypeKeyword">verdicttype</link></entry>
	  <entry>list</entry>
	</row>
	<row id="tt_bitstring">
	  <entry morerows="4" valign="top">Basic string types</entry>
	  <entry><link
	  linkend="BitStringKeyword">bitstring</link></entry>
	  <entry>list, length</entry>
	</row>
	<row id="tt_hexstring">
	  <entry><link
	  linkend="HexStringKeyword">hexstring</link></entry>
	  <entry>list, length</entry>
	</row>
	<row id="tt_octetstring">
	  <entry><link
	  linkend="OctetStringKeyword">octetstring</link></entry>
	  <entry>list, length</entry>
	</row>
	<row id="tt_charstring">
	  <entry><link
	  linkend="CharStringKeyword">charstring</link></entry>
	  <entry>range, list, length</entry>
	</row>
	<row id="tt_universal_charstring">
	  <entry><link linkend="UniversalCharString">universal
	  charstring</link></entry>
	  <entry>range, list, length</entry>
	</row>
	<row id="tt_record">
	  <entry morerows="5" valign="top">Structured types</entry>
	  <entry><link linkend="RecordDef">record</link></entry>
	  <entry>list</entry>
	</row>
	<row id="tt_record_of">
	  <entry><link linkend="RecordOfDef">record of</link></entry>
	  <entry>list, length</entry>
	</row>
	<row id="tt_set">
	  <entry><link linkend="SetDef">set</link></entry>
	  <entry>list</entry>
	</row>
	<row id="tt_set_of">
	  <entry><link linkend="SetOfDef">set of</link></entry>
	  <entry>list, length</entry>
	</row>
	<row id="tt_enumerated">
	  <entry><link linkend="EnumDef">enumerated</link></entry>
	  <entry>list</entry>
	</row>
	<row id="tt_union">
	  <entry><link linkend="UnionDef">union</link></entry>
	  <entry>list</entry>
	</row>
	<row id="tt_anytype">
	  <entry>Special data types</entry>
	  <entry>anytype</entry>
	  <entry>list</entry>
	</row>
	<row id="tt_address">
	  <entry morerows="2" valign="top">Special configuration
	  types</entry>
	  <entry>address</entry>
	  <entry/>
	</row>
	<row id="tt_port">
	  <entry><link linkend="PortDef">port</link></entry>
	  <entry/>
	</row>
	<row id="tt_component">
	  <entry><link linkend="ComponentDef">component</link></entry>
	  <entry/>
	</row>
	<row id="tt_default">
	  <entry>Special default types</entry>
	  <entry><link linkend="DefaultKeyword">default</link></entry>
	  <entry/>
	</row>
      </tbody>
    </tgroup>
  </table>

  <table id="operator-precedence" pgwide="1">
    <title>Precedence of operators</title>
    <tgroup cols="3">
      <colspec align="left"/>
      <colspec align="left"/>
      <colspec align="left"/>
      <thead>
	<row>
	  <entry align="center">Priority</entry>
	  <entry align="center">Operator type</entry>
	  <entry align="center">Operator</entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry>highest</entry>
	  <entry>Unary/Binary</entry>
	  <entry>+, - *, /, mod, rem</entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry>+, -, &amp;</entry>
	</row>
	<row>
	  <entry/>
	  <entry>Unary</entry>
	  <entry>not4b</entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry><link linkend="BitOp">and4b</link></entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry><link linkend="BitOp">xor4b</link></entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry><link linkend="BitOp">or4b</link></entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry>&lt;&lt;, >>, &lt;@, @></entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry>&lt;, >, &lt;=, >=</entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry>==, !=</entry>
	</row>
	<row>
	  <entry/>
	  <entry>Unary</entry>
	  <entry>not</entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry><link linkend="LogicalOp">and</link></entry>
	</row>
	<row>
	  <entry/>
	  <entry>Binary</entry>
	  <entry><link linkend="LogicalOp">xor</link></entry>
	</row>
	<row>
	  <entry>lowest</entry>
	  <entry>Binary</entry>
	  <entry><link linkend="LogicalOp">or</link></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <table id="predefined-functions" pgwide="1">
    <title>TTCN-3 predefined functions</title>
    <tgroup cols="3">
      <colspec align="justify"/>
      <colspec align="justify"/>
      <colspec align="left"/>
      <thead>
	<row>
	  <entry align="center">Category</entry>
	  <entry align="center">Function</entry>
	  <entry align="center">Keyword</entry>
	</row>
      </thead>
      <tbody>
	<row id="tf_int2char">
	  <entry morerows="23" valign="top">Conversion
	  functions</entry>
	  <entry>Convert <link linkend="tt_integer">integer</link>
	  value to <link linkend="tt_char">char</link> value</entry>
	  <entry>int2char</entry>
	</row>
	<row id="tf_int2unichar">
	  <entry>Convert <link linkend="tt_integer">integer</link>
	  value to <link linkend="tt_universal_char">universal
	  char</link> value</entry>
	  <entry>int2unichar</entry>
	</row>
	<row id="tf_int2bit">
	  <entry>Convert <link linkend="tt_integer">integer</link>
	  value to <link linkend="tt_bitstring">bitstring</link>
	  value</entry>
	  <entry>int2bit</entry>
	</row>
	<row id="tf_int2hex">
	  <entry>Convert <link linkend="tt_integer">integer</link>
	  value to <link linkend="tt_hexstring">hexstring</link>
	  value</entry>
	  <entry>int2hex</entry>
	</row>
	<row id="tf_int2oct">
	  <entry>Convert <link linkend="tt_integer">integer</link>
	  value to <link linkend="tt_octetstring">octetstring</link>
	  value</entry>
	  <entry>int2oct</entry>
	</row>
	<row id="tf_int2str">
	  <entry>Convert <link linkend="tt_integer">integer</link>
	  value to <link linkend="tt_charstring">charstring</link>
	  value</entry>
	  <entry>int2str</entry>
	</row>
	<row id="tf_int2float">
	  <entry>Convert <link linkend="tt_integer">integer</link>
	  value to <link linkend="tt_float">float</link> value</entry>
	  <entry>int2float</entry>
	</row>
	<row id="tf_float2int">
	  <entry>Convert <link linkend="tt_float">float</link> value
	  to <link linkend="tt_integer">integer</link> value</entry>
	  <entry>float2int</entry>
	</row>
	<row id="tf_char2int">
	  <entry>Convert <link linkend="tt_char">char</link> value to
	  <link linkend="tt_integer">integer</link> value</entry>
	  <entry>char2int</entry>
	</row>
	<row id="tf_unichar2int">
	  <entry>Convert <link linkend="tt_universal_char">universal
	  char</link> value to <link
	  linkend="tt_integer">integer</link> value</entry>
	  <entry>unichar2int</entry>
	</row>
	<row id="tf_bit2int">
	  <entry>Convert <link linkend="tt_bitstring">bitstring</link>
	  value to <link linkend="tt_integer">integer</link>
	  value</entry>
	  <entry>bit2int</entry>
	</row>
	<row id="tf_bit2hex">
	  <entry>Convert <link linkend="tt_bitstring">bitstring</link>
	  value to <link linkend="tt_hexstring">hexstring</link>
	  value</entry>
	  <entry>bit2hex</entry>
	</row>
	<row id="tf_bit2oct">
	  <entry>Convert <link linkend="tt_bitstring">bitstring</link>
	  value to <link linkend="tt_octetstring">octetstring</link>
	  value</entry>
	  <entry>bit2oct</entry>
	</row>
	<row id="tf_bit2str">
	  <entry>Convert <link linkend="tt_bitstring">bitstring</link>
	  value to <link linkend="tt_charstring">charstring</link>
	  value</entry>
	  <entry>bit2str</entry>
	</row>
	<row id="tf_hex2int">
	  <entry>Convert <link linkend="tt_hexstring">hexstring</link>
	  value to <link linkend="tt_integer">integer</link>
	  value</entry>
	  <entry>hex2int</entry>
	</row>
	<row id="tf_hex2bit">
	  <entry>Convert <link linkend="tt_hexstring">hexstring</link>
	  value to <link linkend="tt_bitstring">bitstring</link>
	  value</entry>
	  <entry>hex2bit</entry>
	</row>
	<row id="tf_hex2oct">
	  <entry>Convert <link linkend="tt_hexstring">hexstring</link>
	  value to <link linkend="tt_octetstring">octetstring</link>
	  value</entry>
	  <entry>hex2oct</entry>
	</row>
	<row id="tf_hex2str">
	  <entry>Convert <link linkend="tt_hexstring">hexstring</link>
	  value to <link linkend="tt_charstring">charstring</link>
	  value</entry>
	  <entry>hex2str</entry>
	</row>
	<row id="tf_oct2int">
	  <entry>Convert <link
	  linkend="tt_octetstring">octetstring</link> value to <link
	  linkend="tt_integer">integer</link> value</entry>
	  <entry>oct2int</entry>
	</row>
	<row id="tf_oct2bit">
	  <entry>Convert <link
	  linkend="tt_octetstring">octetstring</link> value to <link
	  linkend="tt_bitstring">bitstring</link> value</entry>
	  <entry>oct2bit</entry>
	</row>
	<row id="tf_oct2hex">
	  <entry>Convert <link
	  linkend="tt_octetstring">octetstring</link> value to <link
	  linkend="tt_hexstring">hexstring</link> value</entry>
	  <entry>oct2hex</entry>
	</row>
	<row id="tf_oct2str">
	  <entry>Convert <link
	  linkend="tt_octetstring">octetstring</link> value to <link
	  linkend="tt_charstring">charstring</link> value</entry>
	  <entry>oct2str</entry>
	</row>
	<row id="tf_str2int">
	  <entry>Convert <link
	  linkend="tt_charstring">charstring</link> value to <link
	  linkend="tt_integer">integer</link> value</entry>
	  <entry>str2int</entry>
	</row>
	<row id="tf_str2oct">
	  <entry>Convert <link
	  linkend="tt_charstring">charstring</link> value to <link
	  linkend="tt_octetstring">octetstring</link> value</entry>
	  <entry>str2oct</entry>
	</row>
	<row id="tf_lengthof">
	  <entry morerows="1" valign="top">Length/size
	  functions</entry>
	  <entry>Return the length of a value of any string
	  type</entry>
	  <entry>lengthof</entry>
	</row>
	<row id="tf_sizeof">
	  <entry>Return the number of elements in a <link
	  linkend="tt_record">record</link>, <link
	  linkend="tt_record_of">record of</link>, template, <link
	  linkend="tt_set">set</link>, <link linkend="tt_set_of">set
	  of</link> or array</entry>
	  <entry>sizeof</entry>
	</row>
	<row id="tf_ispresent">
          <entry morerows="1" valign="top">Presence/choice
          functions</entry>
	  <entry>Determine if an optional field in a <link
	  linkend="tt_record">record</link>, <link
	  linkend="tt_record_of">record of</link>, template, <link
	  linkend="tt_set">set</link> or
	  <link linkend="tt_set_of">set of</link> is present</entry>
	  <entry>ispresent</entry>
	</row>
	<row id="tf_ischosen">
	  <entry>Determine which choice has been made in a <link
	  linkend="tt_union">union</link> type</entry>
	  <entry>ischosen</entry>
	</row>
	<row id="tf_regexp">
          <entry morerows="1" valign="top">String functions</entry>
	  <entry>Returns part of the input string matching the
	  specified pattern description</entry>
	  <entry>regexp</entry>
	</row>
	<row id="tf_substr">
	  <entry>Returns the specified portion of the input
	  string</entry>
	  <entry>substr</entry>
	</row>
	<row id="tf_rnd">
	  <entry>Other functions</entry>
	  <entry>Generate a random <link
	  linkend="tt_float">float</link> number</entry>
	  <entry>rnd</entry>
        </row>
      </tbody>
    </tgroup>
  </table>

</article>
